#include "ext.h"#include "z_dsp.h"#include <math.h>#include <stdlib.h>#define SLEWRATE_INT 1024          // This is a fixed crossfade between points about 23 msec#define SLEWRATE_FLOAT 1024.0  void *panner5_class;typedef struct _panner5{    t_pxobject x_obj;    t_float x_val;    float RightVal; // Current amplitude values    float LeftVal;  // for each channel    float CentVal;    float RSurrVal;    float LSurrVal;        float DestRightVal; // Destination (future)    float DestLeftVal;  // amplitude values    float DestCentVal;  // for each channel    float DestRSurrVal;    float DestLSurrVal;        float StepRightVal; // Used for cross fades     float StepLeftVal;  // to prevent 'zippering'    float StepCentVal;     float StepRSurrVal;    float StepLSurrVal;        float YFrontComp;   // X-Y Components of Front, Rear and Centre    float YRearComp;    float XRightComp;    float XLeftComp;    float XCentComp;        int SlewCount;     // keep track of slew count                        // which keeps track of how far we are into the crossfade         int XValue;  // memory for X and Y coordinates    int YValue;    } t_panner5;  // my object/*****************************************************************                      Function Prototypes*****************************************************************/void *panner5_new(float val);         		 // constructor functiont_int *panner5_perform(t_int *w);      		 // DSP functionvoid xaxis_int(t_panner5 *x, int i);           // get x-axis valuevoid yaxis_int(t_panner5 *x, int i);           // get y-axis valuevoid panner5_dsp(t_panner5 *x, t_signal **sp, short *count); // Puts function onto DSP stack/*****************************************************************                            Main*****************************************************************/void main(void){    // setup(&panner5_class, panner5_new, (method)dsp_free, (short)sizeof(t_panner5), 0L, A_DEFFLOAT, 0);        setup((Messlist **)&panner5_class, (method)panner5_new, (method)dsp_free, (short)sizeof(t_panner5), 0L, A_GIMME, 0);        addinx((method)yaxis_int, 1);    addinx((method)xaxis_int, 2);    addmess((method)panner5_dsp, "dsp", A_CANT, 0);    dsp_initclass();    rescopy('STR#',3214);}/*****************************************************************                      panner5_new    This is the constructor function. It is executed only when    the panner5 is instanciated.*****************************************************************/void *panner5_new(float val){    float *FilterCoef, c;        t_panner5 *PanObject = (t_panner5 *)newobject(panner5_class);  // malloc new instance of PanObject    dsp_setup((t_pxobject *)PanObject,1);  // setup with one signal inlet    intin(PanObject,1);                    // leftmost inlet is int only (x-axis co-ordinates)    intin(PanObject,2);                    // middle inlet is int only (y-axis co-ordinates)    outlet_new((t_object *)PanObject, "signal"); // signal outlet 1    outlet_new((t_object *)PanObject, "signal"); // signal outlet 2    outlet_new((t_object *)PanObject, "signal"); // signal outlet 3    outlet_new((t_object *)PanObject, "signal"); // signal outlet 4    outlet_new((t_object *)PanObject, "signal"); // signal outlet 5    PanObject->RightVal = 0.0; // Start off with no levels (prevent pop when initialized)    PanObject->LeftVal  = 0.0;     PanObject->CentVal  = 0.0;    PanObject->RSurrVal = 0.0;    PanObject->LSurrVal = 0.0;        PanObject->DestRightVal = 0.87; // Dead centre is first destination level    PanObject->DestLeftVal  = 0.87;     PanObject->DestCentVal  = 0.93;    PanObject->DestRSurrVal = 0.87;    PanObject->DestLSurrVal = 0.87;       PanObject->StepRightVal = ((PanObject->DestRightVal - PanObject->RightVal) / SLEWRATE_FLOAT);// Step values will cause a fade     PanObject->StepLeftVal  = ((PanObject->DestLeftVal - PanObject->LeftVal) / SLEWRATE_FLOAT);  // to eliminate pops when the patch    PanObject->StepCentVal  = ((PanObject->DestCentVal - PanObject->CentVal) / SLEWRATE_FLOAT);  // is started up    PanObject->StepRSurrVal = ((PanObject->DestRSurrVal - PanObject->RSurrVal) / SLEWRATE_FLOAT);    PanObject->StepLSurrVal = ((PanObject->DestLSurrVal - PanObject->LSurrVal) / SLEWRATE_FLOAT);       PanObject->YFrontComp  = 0.93;    PanObject->YRearComp   = 0.93;    PanObject->XRightComp  = 1.00;    PanObject->XLeftComp   = 0.93;    PanObject->XCentComp = 0.93;        PanObject->SlewCount = SLEWRATE_INT;        PanObject->XValue = 125;    PanObject->YValue = 125;          return (PanObject);}/*****************************************************************                      xaxis_int*****************************************************************/void xaxis_int(t_panner5 *PanObject, int NewXValue){      float X_AsFloat;      if (NewXValue != PanObject->XValue)  // don't bother doing anything if the XValue hasn't changed    {               X_AsFloat = (float) NewXValue; // do this only once (it's expensive)            if (NewXValue < 1) NewXValue = 0;           // dissallow illegal values       else if (NewXValue > 249) NewXValue = 249;  // only 1 to 249 is legal            PanObject->XLeftComp = pow(sin( ((250.0 - X_AsFloat) / 250.0) * 1.570795), 0.2); // re-calculate x components only       PanObject->XRightComp = pow(sin((X_AsFloat / 250.0) * 1.570795), 0.2);       PanObject->XCentComp = pow(sin(((250.0 - (2.0 * (abs(X_AsFloat - 125.0)))) / 250.0) * 1.570795), 0.2);       // New X components will almost always cause new destination values in all channels            PanObject->DestLeftVal  = (PanObject->YFrontComp) * (PanObject->XLeftComp);        PanObject->DestRightVal = (PanObject->YFrontComp) * (PanObject->XRightComp);       PanObject->DestCentVal  = (PanObject->YFrontComp) * (PanObject->XCentComp);       PanObject->DestRSurrVal = (PanObject->YRearComp) * (PanObject->XRightComp);       PanObject->DestLSurrVal = (PanObject->YRearComp) * (PanObject->XLeftComp);              // Calculate step amount for crossfade (linear)              PanObject->StepRightVal = ((PanObject->DestRightVal - PanObject->RightVal) / SLEWRATE_FLOAT); // the '.0' is to make sure it is a float       PanObject->StepLeftVal  = ((PanObject->DestLeftVal - PanObject->LeftVal) / SLEWRATE_FLOAT);   // this should mean 1 less int to float conversion       PanObject->StepCentVal  = ((PanObject->DestCentVal - PanObject->CentVal) / SLEWRATE_FLOAT);       PanObject->StepRSurrVal = ((PanObject->DestRSurrVal - PanObject->RSurrVal) / SLEWRATE_FLOAT);       PanObject->StepLSurrVal = ((PanObject->DestLSurrVal - PanObject->LSurrVal) / SLEWRATE_FLOAT);              PanObject->SlewCount = SLEWRATE_INT;                   PanObject->XValue = NewXValue;    }         /*   post("X: %i",PanObject->XValue); // for debugging only   post("1: %f",PanObject->LeftVal); // for debugging only   post("2: %f",PanObject->RightVal); // for debugging only   post("3: %f",PanObject->CentVal); // for debugging only   post("4: %f",PanObject->RSurrVal); // for debugging only   post("5: %f",PanObject->LSurrVal); // for debugging only   post("SR: %i",PanObject->SlewCount); // for debugging only   */     }/*****************************************************************                      yaxis_int*****************************************************************/void yaxis_int(t_panner5 *PanObject, int NewYValue){   float Y_AsFloat;     if (NewYValue != PanObject->YValue)  // don't bother doing anything if the YValue hasn't changed    {        if (NewYValue < 1) NewYValue = 249;           // This is to compensate for MAX's LCD object (its backwards)       else if (NewYValue > 249) NewYValue = 1;      // dissallow illegal values       else NewYValue = (249 - NewYValue);           // only 1 to 249 is legal       Y_AsFloat = (float) NewYValue; // do this only once (expensive)              PanObject->YRearComp = pow(sin( ((250.0 - Y_AsFloat) / 250.0) * 1.570795), 0.2); // re-calculate y components only       PanObject->YFrontComp = pow(sin((Y_AsFloat / 250.0) * 1.570795), 0.2);              // New Y components will almost always cause new destination values in all channels              PanObject->DestLeftVal  = (PanObject->YFrontComp) * (PanObject->XLeftComp);        PanObject->DestRightVal = (PanObject->YFrontComp) * (PanObject->XRightComp);       PanObject->DestCentVal  = (PanObject->YFrontComp) * (PanObject->XCentComp);       PanObject->DestRSurrVal = (PanObject->YRearComp) * (PanObject->XRightComp);       PanObject->DestLSurrVal = (PanObject->YRearComp) * (PanObject->XLeftComp);              // Calculate step amount for crossfade (linear)              PanObject->StepRightVal = ((PanObject->DestRightVal - PanObject->RightVal) / SLEWRATE_FLOAT); // the '.0' is to make sure it is a float       PanObject->StepLeftVal  = ((PanObject->DestLeftVal - PanObject->LeftVal) / SLEWRATE_FLOAT);   // this should mean fewer int to float conversions       PanObject->StepCentVal  = ((PanObject->DestCentVal - PanObject->CentVal) / SLEWRATE_FLOAT);       PanObject->StepRSurrVal = ((PanObject->DestRSurrVal - PanObject->RSurrVal) / SLEWRATE_FLOAT);       PanObject->StepLSurrVal = ((PanObject->DestLSurrVal - PanObject->LSurrVal) / SLEWRATE_FLOAT);                  PanObject->SlewCount = SLEWRATE_INT;                   PanObject->YValue = NewYValue;    }  /*   post("X: %i",PanObject->XValue); // for debugging only   post("1: %f",PanObject->LeftVal); // for debugging only   post("2: %f",PanObject->RightVal); // for debugging only   post("3: %f",PanObject->CentVal); // for debugging only   post("4: %f",PanObject->RSurrVal); // for debugging only   post("5: %f",PanObject->LSurrVal); // for debugging only   post("SR: %i",PanObject->SlewCount); // for debugging only  */   }/*****************************************************************                      panner5_perform   This is where all the DSP is done.*****************************************************************/t_int *panner5_perform(t_int *w){    t_panner5 *PanObject = (t_panner5 *) (w[1]);	float *in = (float *) (w[2]);	float *Left  = (float *) (w[3]);	float *Right = (float *) (w[4]);	float *Cent  = (float *) (w[5]);	float *LSurr  = (float *) (w[6]);	float *RSurr  = (float *) (w[7]);	long VectorSize = w[8];    float PutInRegister;     while ((PanObject->SlewCount) && (VectorSize))    {      PutInRegister = *in;          *Cent++  = PutInRegister * (PanObject->CentVal += PanObject->StepCentVal);      *RSurr++ = PutInRegister * (PanObject->RSurrVal += PanObject->StepRSurrVal);      *LSurr++ = PutInRegister * (PanObject->LSurrVal += PanObject->StepLSurrVal);      *Right++ = PutInRegister * (PanObject->RightVal += PanObject->StepRightVal);      *Left++  = PutInRegister * (PanObject->LeftVal += PanObject->StepLeftVal);           VectorSize--;      PanObject->SlewCount--;      in++;         }       while (VectorSize)    {      PutInRegister = *in;           *Cent++  = PutInRegister * PanObject->CentVal;      *RSurr++ = PutInRegister * PanObject->RSurrVal;      *LSurr++ = PutInRegister * PanObject->LSurrVal;           *Right++ = PutInRegister * PanObject->RightVal;      *Left++  = PutInRegister * PanObject->LeftVal;      VectorSize--;      in++;          }     	return (w+9);  // required by MAX/MSP}		/*****************************************************************                      panner5_dsp        MSP pushing my DSP function onto the DSP stack.*****************************************************************/void panner5_dsp(t_panner5 *PanObject, t_signal **sp, short *count){		if (count[0]) // if there is a signal attached to the inlet	 {	   dsp_add(panner5_perform, 8, PanObject, sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, 	                                          sp[3]->s_vec, sp[4]->s_vec, sp[5]->s_vec, sp[0]->s_n);	 } }