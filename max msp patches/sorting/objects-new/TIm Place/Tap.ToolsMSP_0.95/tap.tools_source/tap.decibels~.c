// MSP External: decibels~.c// dB/amplitude converter// T.Place - 4/28/2001//		v1.1 (08/27/01) - update for Max/MSP 4//		v1.2 (11/30/2001) - minor improvements#include "ext.h"				// Required for all Max External Objects#include "z_dsp.h"			// Required for all MSP External Objects#include <math.h>		#include "ext_strings.h"	void *decibels_class;			// Required. Global pointing to this classtypedef struct _decibels		// Data Structure for this object{	t_pxobject x_obj;	void *decibels_out;		// Floating-point outlet	int decibels_mode;		// mode number} t_decibels;// Prototypes for methods: need a method for each incoming message type:t_int *decibels_perform(t_int *w);							// An MSP Perform (signal) Methodvoid decibels_dsp(t_decibels *x, t_signal **sp, short *count);		// DSP Methodvoid decibels_assist(t_decibels *x, void *b, long m, long a, char *s);	// Assistance Methodvoid *decibels_new(t_symbol *msg, short argc, t_atom *argv);		// New Object Creation Methodvoid decibels_float(t_decibels *x, double value);				// Float methodvoid decibels_mode(t_decibels *x, int value);					// 'mode' methodvoid decibels_free(t_decibels *x);/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&decibels_class, (method)decibels_new, (method)decibels_free, (short)sizeof(t_decibels), 0L, A_GIMME, 0);	    						addmess((method)decibels_dsp, "dsp", A_CANT, 0);					// Bind method "decibels_dsp" to the DSP call from MSP	addmess((method)decibels_assist,"assist", A_CANT, 0);				// Bind method "decibels_assist" to assistance calls	addfloat((method)decibels_float);								// Bind method to float input	addmess((method)decibels_mode, "mode", A_LONG, 0);				// Bind the 'mode' method	addmess((method)inspector_open, "info", A_CANT, 0);				// bind method for opening the license window		dsp_initclass();												// Setup object's class to work with MSP	alias("decibels~");											// ...for backwards compatibility	alias("tap.atodb~");	alias("tap.dbtoa~");	post("tap.decibels~ v1.2 - Copyright © 2001 by Timothy A. Place");		// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *decibels_new(t_symbol *msg, short argc, t_atom *argv){	t_decibels *x = (t_decibels *)newobject(decibels_class);	dsp_setup((t_pxobject *)x,1);    	x->decibels_out = floatout(x);						// Create a floating-point Outlet	outlet_new((t_object *)x, "signal");	if (msg == gensym("tap.atodb~"))	{		x->decibels_mode = 0;		post("     tap.decibels~ initialized in mode 0");	}	else if (msg == gensym("tap.dbtoa~"))	{		x->decibels_mode = 1;		post("     tap.decibels~ initialized in mode 1");	}	else x->decibels_mode = atom_getfloatarg(0,argc,argv);	return (x);}/************************************************************************************/// Methods bound to input/inlets// Method for Assistance Messagesvoid decibels_assist(t_decibels *x, void *b, long msg, long arg, char *dst){	if(msg==1) 		// Inlets		strcpy(dst, "(signal/float) Input");	else if(msg==2){ 	// Outlets		switch(arg){			case 0: strcpy(dst, "(signal) Output"); break;			case 1: strcpy(dst, "(float) Output"); break;		}	}}// 'mode' methodvoid decibels_mode(t_decibels *x, int value){	x->decibels_mode = value;}// method for float inputvoid decibels_float(t_decibels *x, double value){	switch (x->decibels_mode) 	{		case 0:			if (value >= 0)			{				value = 20. * (log10(value));				outlet_float(x->decibels_out, value);	// output the result			}			break;		case 1:			value = pow(10., (value / 20.));			outlet_float(x->decibels_out, value);		// output the result								break;	}}// Memory Deallocationvoid decibels_free(t_decibels *x){	notify_free((t_object *)x);	dsp_free((t_pxobject *)x);}// Perform (signal) Method - delay is a constant (not a signal)t_int *decibels_perform(t_int *w){	t_float *in, value, *out;	int n;	t_decibels *x = (t_decibels *)(w[1]);			in = (t_float *)(w[2]);	out = (t_float *)(w[3]);	n = (int)(w[4]);		if (x->x_obj.z_disabled) goto out;			while (--n) 	{		value = *++in;							// Input		switch (x->decibels_mode) 		{			case 0:				if (value >= 0)				{					value = 20. * (log10(value));					*++out = value;				// output the result				}				else					*++out = -9999.;				break;			case 1:				value = pow(10., (value / 20.));				*++out = value;					// output the result									break;		}	}out:	return (w+5);}// DSP Methodvoid decibels_dsp(t_decibels *x, t_signal **sp, short *count){	int val;	if (count[0])   		dsp_add(decibels_perform, 4, x, sp[0]->s_vec-1, sp[1]->s_vec-1, sp[0]->s_n + 1);   	else   		val = 0;}