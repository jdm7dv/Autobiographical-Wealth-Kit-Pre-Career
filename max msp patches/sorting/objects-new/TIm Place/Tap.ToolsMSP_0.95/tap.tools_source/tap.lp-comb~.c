// MSP External: tap.lp-comb~.c// Comb filter with a lopass filter in the feedback loop// T.Place - 2/18/2001; based on comb~ from the standard MSP distribution//		v1.1 (6/12/01) - added autoclip option to automatically clip out of range samples to prevent blow ups.//		v1.2 (08/27/01) - update for Max/MSP 4//		v1.3 (12/14/01) - minor revisions#include "ext.h"					// Required for all Max External Objects#include "z_dsp.h"				// Required for all MSP External Objects#include <math.h>			#include "ext_strings.h"			// Used for the assistance stringsvoid *comb_class;				// Required. Global pointing to this classenum {	MAX_DELAY_DEFAULT = 10, 	// (in milliseconds)	MIN_DELAY = 24,	NUM_INPUTS = 4};typedef struct _comb			// Data Structure for this object{	t_pxobject x_obj;	float 	*x_memory;	float 	*x_input;	float 	*x_ialloc;	float 	*x_alloc;	float 	x_delaysize;	long 		x_delay;	float 	x_msdelay;	long 		x_imaxdelay;	float 	x_fmaxdelay;	float 	x_ccoeff;	float 	*x_memwriteptr;	float 	*x_inwriteptr;	float 	x_msr;	double 	lpass_feedback;	// feedback sample for lpass() function	float 	lpass_coef;	float 	comb_delay2;		// delay time as constant - used to calculate decay	float 	x_decayTime;	int		x_autoclip;		// flag for automatic clipping of the comb output.} t_comb;// Prototypes for methods: need a method for each incoming message type:float fclip(float a, float b, float c);						//long clip(long a, long b, long c);							//t_int *comb_perform(t_int *w);						// An MSP Perform (signal) Methodt_int *comb2_perform(t_int *w);						// An MSP Perform (signal) Methodvoid comb_float(t_comb *x, double phase);				//void comb_int(t_comb *x, long n);						//void comb_dsp(t_comb *x, t_signal **sp, short *count);		// DSP Methodvoid comb_assist(t_comb *x, void *b, long m, long a, char *s);	// Assistance Methodvoid comb_free(t_comb *x);							// Memory Deallocation Functionvoid comb_deallocate(t_comb *x);						// More Memory Deallocation Functionvoid comb_allocate(t_comb *x, double msr);				// Memory Allocation Functionvoid comb_clear(t_comb *x);							// "Clear" Methodvoid *comb_new(t_symbol *s, short argc, t_atom *argv);		// New Object Creation Methodvoid comb_lpass(t_comb *x, float hz);					//double hz_radians(double hz);							//double lpass(t_comb *x, double inSamp);					//void comb_lpassx(t_comb *x, float coef);					// directly specify the lpass coeffvoid comb_delay2(t_comb *x, float delay);				// method to define delay constant.void decay_to_fb(t_comb *x);							//void comb_feedback(t_comb *x, double feedback);			// directly specify the feedbackvoid comb_autoclip(t_comb *x, long toggle);				// toggle autoclipping/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&comb_class, (method)comb_new, (method)comb_free, (short)sizeof(t_comb), 0L, A_GIMME, 0);	    						addmess((method)comb_dsp, "dsp", A_CANT, 0);					// Bind method "comb_dsp" to the DSP call from MSP	addfloat((method)comb_float);									// Bind method "comb_float" to float input	addint((method)comb_int);									// Bind method "comb_int" to int input	addmess((method)comb_assist,"assist", A_CANT, 0);				// Bind method "comb_assist" to assistance calls	addmess((method)comb_clear,"clear",0);							// Bind method "comb_clear" to clear messages	addmess((method)comb_lpass, "lpass", A_FLOAT, 0);				//	addmess((method)comb_lpassx, "lpassx", A_FLOAT, 0);				//	addmess((method)comb_delay2, "delay2", A_FLOAT, 0);				//	addmess((method)comb_feedback, "feedback", A_FLOAT, 0);			//	addmess((method)comb_autoclip, "autoclip", A_LONG, 0);				// 	addmess((method)inspector_open, "info", A_CANT, 0);				// bind method for opening the license window		dsp_initclass();												// Setup object's class to work with MSP	alias("lp-comb~");											// ...for backwards compatibility	post("tap.lp-comb~ v1.3 - Copyright © 2001 by Timothy A. Place");		// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *comb_new(t_symbol *s, short argc, t_atom *argv){	double delay;	t_comb *x = (t_comb *)newobject(comb_class);	dsp_setup((t_pxobject *)x,3);	outlet_new((t_object *)x, "signal");	delay = atom_getfloatarg(0,argc,argv);					// store the delay buffer size argument (arg 1)	x->x_msr = sys_getsr() * 0.001;	x->x_alloc = 0;	x->x_ialloc = 0;	x->x_delaysize = delay > 0? delay : MAX_DELAY_DEFAULT;	// init the size of the delay buffer	comb_allocate(x,x->x_msr);	x->x_msdelay = atom_getfloatarg(1,argc,argv);			// init the initial the delay time (arg 2)	x->comb_delay2 = atom_getfloatarg(1,argc,argv);			// ...	x->x_delay = 0;	x->x_ccoeff = atom_getfloatarg(2,argc,argv);				// init the initial the feedback coefficient (arg 3)	x->x_autoclip = atom_getfloatarg(3,argc,argv);			// init the initial toggle state for autoclipping (arg 4)	x->lpass_coef = 0.1;   								// lpass	x->lpass_feedback = 0;								// init the feedback sample	return (x);}/************************************************************************************/// Methods bound to input/inlets// Method for Assistance Messagesvoid comb_assist(t_comb *x, void *b, long msg, long arg, char *dst){	if(msg==1){ 	// Inlets		switch(arg){			case 0: strcpy(dst, "(signal) Input"); break;			case 1: strcpy(dst, "(signal/float) Delay Time in ms"); break;			case 2: strcpy(dst, "(float) Decay Time in seconds"); break;		}	}	else if(msg==2) // Outlets		strcpy(dst, "(signal) Filtered Output");}// Method for the "clear" messagevoid comb_clear(t_comb *x){	long i;		for (i = 0; i < x->x_imaxdelay + 4; i++) 	{		x->x_alloc[i] = 0.;		x->x_ialloc[i] = 0.;	}	x->lpass_feedback = 0;	}// lpass Method - define the lowpass coefficient by its cutoff frequencyvoid comb_lpass(t_comb *x, float hz)	{	double radians;	radians = hz_radians(hz);			// hz->radians conversion	radians = radians / 3.141593;	radians = fclip(radians, 0, 1);		//limit values...		x->lpass_coef = radians;}// lpassx Method - define the lowpass coefficient directlyvoid comb_lpassx(t_comb *x, float coef)	{	x->lpass_coef = 1 - (fclip(coef, 0, 1));}// delay2 method - delay constant used to calculate decay timevoid comb_delay2(t_comb *x, float delay){	x->comb_delay2 = delay;	decay_to_fb(x);}// feedback method - directly specify the coefficientvoid comb_feedback(t_comb *x, double feedback){	x->x_ccoeff = feedback;}// toggle on and off the automatic clippingvoid comb_autoclip(t_comb *x, long toggle){	x->x_autoclip = toggle;}// Method for Int inputvoid comb_int(t_comb *x, long n){	comb_float(x,(double)n);	// cast as double-precision-float and pass off the data}// Method for float inputvoid comb_float(t_comb *x, double val){	switch (x->x_obj.z_in) {		case 1:			x->x_msdelay = val;			x->x_delay = clip(val * x->x_msr,1,x->x_imaxdelay);			x->comb_delay2 = val;			break;		case 2:			x->x_decayTime = val;			decay_to_fb(x);			break;	}}// Perform (signal) Method - delay is a constant (not a signal)t_int *comb_perform(t_int *w){	t_float *in, ccoeff, val, *out;	int n;	float *omemend,*omemwriteptr,*omemreadptr, coef;	double fb, combFB;	t_comb *x = (t_comb *)(w[1]);			in = (t_float *)(w[2]);	out = (t_float *)(w[3]);	n = (int)(w[4]);		if (x->x_obj.z_disabled) goto out;			fb = x->lpass_feedback;						// feedback sample for lopass filter	coef = x->lpass_coef;						// feedback Coef for lowpass filter	ccoeff = x->x_ccoeff;						// feedback coef for comb filter	omemend = x->x_memory + x->x_imaxdelay;	omemwriteptr = x->x_memwriteptr;	omemreadptr = omemwriteptr - x->x_delay;	if (omemreadptr < x->x_memory) 		omemreadptr = omemend - (x->x_memory - omemreadptr);								while (--n) 	{		val = *++in;											// Input		combFB = *omemreadptr;		combFB = (combFB * coef) + (fb * (1 - coef)); fb = combFB;		// LowPass Filter...		if (x->x_autoclip != 0)			combFB = fclip(combFB, -1.0, 1.0);					*++out = *omemwriteptr++ = val + (ccoeff * combFB);				if (++omemreadptr >= omemend)			omemreadptr = x->x_memory;		if (omemwriteptr >= omemend) 			omemwriteptr = x->x_memory;			}	x->x_memwriteptr = omemwriteptr;	x->lpass_feedback = fb;						// Store Feedback Sampleout:	return (w+5);}// Perform (signal) Method - delay is a signalt_int *comb2_perform(t_int *w){	t_float *in, *del, ccoeff, *out;	int n;	float maxdelay,cr,val;	float msr,*omembegin,*omemend,*omemwriteptr,*omemreadptr, coef;	double fb;	t_comb *x = (t_comb *)(w[1]);			in = (t_float *)(w[2]);	del = (t_float *)(w[3]);	out = (t_float *)(w[4]);	n = (int)(w[5]);	if (x->x_obj.z_disabled)		goto out;	ccoeff = x->x_ccoeff;	fb = x->lpass_feedback;					// feedback sample for lopass filter	coef = x->lpass_coef;					// feedback Coef for lopass	maxdelay = x->x_fmaxdelay;	msr = x->x_msr;	omembegin = x->x_memory;	omemend = x->x_memory + x->x_imaxdelay;	omemwriteptr = x->x_memwriteptr;	while (--n) {		float delay = fclip(*++del * msr,1.0,maxdelay);		long int_delay = delay;		float frac_delay = delay - int_delay;		val = *++in;		omemreadptr = omemwriteptr - int_delay;		if (omemreadptr < omembegin)			omemreadptr = omemend - (omembegin - omemreadptr);		cr =  (*omemreadptr + frac_delay*(*(omemreadptr-1)-*omemreadptr));		cr = (cr * coef) + (fb * (1 - coef)); fb = cr;		// LowPass Filter...				if (x->x_autoclip != 0)			cr = fclip(cr, -1.0, 1.0);		*++out = *omemwriteptr++ = val + (ccoeff * cr);	// Calculate sample and Output!		if (omemwriteptr >= omemend) 		{			*(omembegin-1) = *(omemwriteptr-1);			omemwriteptr = omembegin;		}	}	x->x_memwriteptr = omemwriteptr;	x->lpass_feedback = fb;							// Store Feedback Sampleout:	return (w+6);}// DSP Methodvoid comb_dsp(t_comb *x, t_signal **sp, short *count){    float msr;        msr = sp[0]->s_sr * 0.001;    if (msr != x->x_msr)     {    	comb_allocate(x,msr);    	x->x_msr = msr;    }     comb_clear(x);    x->x_delay = clip(x->x_msdelay * x->x_msr,1,x->x_imaxdelay);    x->x_memwriteptr = x->x_memory + x->x_delay;    x->x_inwriteptr = x->x_input + x->x_delay;        if (count[1])		// delay is a signal    	dsp_add(comb2_perform, 5, x, sp[0]->s_vec-1, sp[1]->s_vec-1, sp[3]->s_vec-1, sp[0]->s_n + 1);    else			// delay is a constant (non-signal)   		dsp_add(comb_perform, 4, x, sp[0]->s_vec-1, sp[3]->s_vec-1, sp[0]->s_n + 1);}/************************************************************************************/// Other Functions used by object// Memory Allocationvoid comb_allocate(t_comb *x, double msr){	comb_deallocate(x);			x->x_imaxdelay = x->x_delaysize * msr;	if (x->x_imaxdelay < MIN_DELAY)    	x->x_imaxdelay = MIN_DELAY;	x->x_fmaxdelay = x->x_imaxdelay;	x->x_alloc = t_getbytes((x->x_imaxdelay + 4) * sizeof(float));	x->x_memory = x->x_alloc + 1;	x->x_ialloc = t_getbytes((x->x_imaxdelay + 4) * sizeof(float));	x->x_input = x->x_ialloc + 1;}// Memory Deallocationvoid comb_free(t_comb *x){	comb_deallocate(x);	notify_free((t_object *)x);	dsp_free((t_pxobject *)x);}// More Memory Deallocationvoid comb_deallocate(t_comb *x){	if (x->x_alloc)		t_freebytes(x->x_alloc,(x->x_imaxdelay + 4) * sizeof(float));	if (x->x_ialloc)		t_freebytes(x->x_ialloc,(x->x_imaxdelay + 4) * sizeof(float));	x->x_alloc = x->x_ialloc = 0;}// Utility function to keep coefficients in checklong clip(long a, long b, long c){	return a < b? b: (a > c? c : a);}// Utility function to keep coefficients in checkfloat fclip(float a, float b, float c){	return a < b? b: (a > c? c : a);}// LowPass filterdouble lpass(t_comb *x, double inSamp){	double fb = x->lpass_feedback;					// feedback sample for lopass filter	float coef = x->lpass_coef;						// feedback Coef	inSamp = (inSamp * (1 - coef)) + (fb * coef);	// Filter...		fb = inSamp;													x->lpass_feedback = fb;						// Store Feedback Sample	return(fb);}// hz->radians conversiondouble hz_radians(double hz){	double radians;	long sr = sys_getsr();		radians = hz * (3.141593 / (sr * 0.5));	return(radians);}// Decay Time (seconds) to feedback coefficient conversionvoid decay_to_fb(t_comb *x){	float	decayTime = x->x_decayTime;	float 	delay = x->comb_delay2;	float 	fb;			delay = delay * 0.001;		// convert delay from milliseconds to seconds	fb = delay / decayTime;			fb = fb * -60.;	fb = pow(10., (fb / 20.));	x->x_ccoeff = fb;}