// MSP External: sift~.c// An MSP object to "sift" out unwanted sample values and convert to floats// T.Place - January 2000// 		v1.1 (02/13/2000) - fixed bug: was only vector accurate, now sample accurate// 		v1.2 (05/04/2000)- filters out consecutive repeated sample values in the signal stream//		v1.3 (08/26/2001) - update for Max/MSP 4//		v2.0 (01/08/2002) - change output method, minor improvements#include "ext.h"				// Required for all Max External Objects#include "z_dsp.h"			// Required for all MSP External Objects#include "ext_strings.h"		// Used for the assistance strings#define VERSION "tap.sift~ v2.0 - Copyright © 2000-2002 by Timothy A. Place"#define QMAX 100			// Number of slots in the queuevoid *sift_class;				// Required. Global pointing to this classtypedef struct _sift			// Data Structure for this object{	t_pxobject x_obj;		// Header;  Must always be the first field; used by MSP	long sift_value;		    	// Value from the typed in argument   	float sift_hold;			// Last value output   	void *sift_out;			// Pointer to outlet. need one for each outlet    	long sift_mode;			// signal or float mode   	void	*sift_clock;		// Pointer to the clock object   	float sift_queuea[QMAX];	  	long sift_qhead, sift_qtail;} t_sift;// Prototypes for methods: need a method for each incoming message typevoid *sift_new(double value, long mode);					// New Object Creation Methodt_int *sift_perform(t_int *w);							// An MSP Perform (signal) Methodvoid sift_dsp(t_sift *x, t_signal **sp);					// DSP Methodvoid sift_assist(t_sift *x, void *b, long m, long a, char *s);		// Assistance Methodvoid sift_free(t_sift *x);								// Release Memoryt_int *sift_perform2(t_int *w);							// Signal Output Mode Methodvoid sift_output (t_sift *x);							// Scheduled floating-point output/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&sift_class, (method)sift_new, (method)sift_free, (short)sizeof(t_sift), 0L, A_DEFFLOAT, A_DEFLONG, 0);	addmess((method)sift_dsp, "dsp", A_CANT, 0);				// Bind method "sift_dsp" to the DSP call from MSP	addmess((method)sift_assist, "assist", A_CANT, 0);			// Bind method "sift_assist" to assistance calls	addmess((method)inspector_open, "info", A_CANT, 0);			// bind method for opening the license window		dsp_initclass();										// Setup object's class to work with MSP	alias("sift~");										// ...for backwards compatibility	post(VERSION, 0);									// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *sift_new(double value, long mode){	int i;	t_sift *x = (t_sift *)newobject(sift_class);	dsp_setup((t_pxobject *)x, 1);						// Create Object and 1 Inlet	if (mode == 0) x->sift_out = floatout(x);				// Create a floating-point Outlet	 	else outlet_new((t_pxobject *)x, "signal");				// OR create a signal Outlet    	x->sift_clock = clock_new(x, (method)sift_output);		// Create the queue clock		x->sift_value = value;								// Init the typed in argument	x->sift_hold = 0.;								// Init hold variable	x->sift_mode = mode;								// Set the mode flag	x->sift_qhead = x->sift_qtail = 0;					// init the the head and tail locations	for(i=0;i<QMAX;i++) x->sift_queuea[i] = 0.;			// init the queue	return x;										// Return pointer}/************************************************************************************/// Methods bound to input/inlets// Method for Assistance Messagesvoid sift_assist(t_sift *x, void *b, long msg, long arg, char *dst){	if(msg==1) 	// Inlets		strcpy(dst, "(signal) To be sifted away");	else if(msg==2){ // Outlets		if(x->sift_mode == 0) strcpy(dst, "(float) remaining sample values");			else strcpy(dst, "(signal) remaining sample values");		}	}// Memory Deallocationvoid sift_free(t_sift *x){	clock_unset(x->sift_clock);	// remove the clock routine from the scheduler	clock_free(x->sift_clock);		// free the clock memory	notify_free((t_object *)x);	// added because of the getinfo window	dsp_free((t_pxobject *)x);	// regular MSP free routine}// Float Outputvoid sift_output (t_sift *x){	long head, tail;	float q[QMAX];	int i;		head = x->sift_qhead;	tail = x->sift_qtail;	for (i=0;i<QMAX;i++) q[i] = x->sift_queuea[i];		while(tail != head){		outlet_float(x->sift_out, q[tail]);			// Spit out the sample value		tail++;		if (tail >= QMAX) tail = 0;	}	x->sift_qtail = tail;	}// Perform (signal) Methodt_int *sift_perform(t_int *w){	t_float *in = (t_float *)(w[1]);						// Input     	t_sift *x = (t_sift *)(w[2]);						// Object Pointer	int n = (int)(w[3]);								// Vector Size	float value;										// Variable for temporary storage 	long qhead = x->sift_qhead; 	int changeFlag = 0; 		while (--n){		value = *++in;		if ((value != x->sift_value) && (value != x->sift_hold)){ 	// If sample is NOT argument && Not the same as the last sample			x->sift_queuea[qhead] = value;								qhead++;			if(qhead >= QMAX) qhead = 0;			changeFlag = 1;		}		x->sift_hold = value;							// Store the output for future comparisons	}	if(changeFlag == 1){		x->sift_qhead = qhead;		clock_delay(x->sift_clock, 0);					// Set clock to go off ASAP	}		return (w + 4);									// return pointer to NEXT object in dsp chain}// Perform (signal) Methodt_int *sift_perform2(t_int *w){	t_float *in = (t_float *)(w[1]);		// Input  	t_float *out = (t_float *)(w[2]);		// Output   	t_sift *x = (t_sift *)(w[3]);		// Object Pointer	int n = (int)(w[4]);				// Vector Size	float value;						// Variable for temporary storage 	while (--n){		value = *++in;		if (value != x->sift_value) {		// If sample is NOT argument			*++out = value;				x->sift_hold = value;		}		else			*++out = x->sift_hold;		// Store the output for future comparisons	}	return (w + 5);					// return pointer to NEXT object in dsp chain}// DSP Methodvoid sift_dsp(t_sift *x, t_signal **sp){	if (x->sift_mode == 0) dsp_add(sift_perform, 3, sp[0]->s_vec-1, x, sp[0]->s_n+1);	// Float Output Mode	else dsp_add(sift_perform2, 4, sp[0]->s_vec-1, sp[1]->s_vec-1, x, sp[0]->s_n+1);	// Signal Output Mode}