// MSP External: tap.avg~.c// An expanded version of the MSP avg~ object// T.Place - 02.12-13.2001// 		v1.1 (2/16/2001) - bug fix: 0/0 when polled too frequently//		v1.2 (3/6/2001) - //		v1.3 (3/29/2001) -//		v1.4 (7/20/2001) - //		v1.5	() - Includes variable modes (mode 1 is the old tap.avg+~ algorithm)//		v1.6 (08/27/01) - update for Max/MSP 4//		v1.7 (12/14/01) - minor revisions#include "ext.h"					// Required for all Max External Objects#include "z_dsp.h"				// Required for all MSP External Objects#include <math.h>				// Required for the sqrt function#include "ext_strings.h"			// Used for the assistance stringsvoid *avg_class;				// Required. Global pointing to this classtypedef struct _avg				// Data Structure for this object{	t_pxobject x_obj;	double	avg_sampleSum;		// Sum of all samples received since reset	double	avg_sampleQuantity;		// Number of samples received since reset	double	avg_average;			// Sum / Number	void		*avg_out;				// pointer to our float outlet	float		line_slewTime;			// Time (in samples) for interpolation to the new value	double	line_destination;		// New value to interpolation to	double	line_step;				// Increment size per sample of time	double	line_result;			// Last output	double	line_samplenum;		// Number of samples to interpolate over	int		line_samplesDone;		// Current location in the interpolation process	void		*metro_clock;			// Pointer to the clock object	float		metro_interval;			// Tempo in ms for auto-analysis	int		avg_poll;				// Auto-analysis toggle	long		avg_outletConfig;		// Outlet routing (0 = both, 1 = signal only, 2 = float only)	long		avg_mode, avg_sr;	double	avg_coef, avg_fb;} t_avg;// Prototypes for methods: need a method for each incoming message typevoid *avg_new(t_symbol *msg, short argc, t_atom *argv);t_int *avg_perform(t_int *w);									// An MSP Perform (signal) Methodvoid avg_dsp(t_avg *x, t_signal **sp, short *count);					// DSP Methodvoid avg_assist(t_avg *x, void *b, long m, long a, char *s);			// Assistance Methodvoid avg_bang(t_avg *x);										// Bang Methodvoid avg_ft1(t_avg *x, double f);								// Second Inletvoid avg_ft2(t_avg *x, double f);								// Third Inletvoid clock_function(t_avg *x);									// Clock Functionvoid avg_free(t_avg *x);										// Memory De-allocationvoid avg_poll(t_avg *x, int toggle);								// auto-poll togglevoid avg_route(t_avg *x, int outletConfig);						// Outlet configurationvoid avg_mode(t_avg *x, long value);void avg_coef(t_avg *x, double coef);t_int *avg_perform2(t_int *w);float fclip(float a, float b, float c);/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&avg_class, (method)avg_new, (method)avg_free, (short)sizeof(t_avg), 0L, A_GIMME, 0);	addmess((method)avg_dsp, "dsp", A_CANT, 0);					// Bind method "avg_dsp" to the DSP call from MSP	addmess((method)avg_assist, "assist", A_CANT, 0);				// Bind method "avg_assist" to assistance calls	addbang((method)avg_bang);								// Bind method "avg_bang" to bang messages	addftx((method)avg_ft1, 1);								// interpolation time	addftx((method)avg_ft2, 2);								// auto-analysis time	addmess((method)avg_poll, "poll", A_LONG, 0);					// toggle auto-analysis	addmess((method)avg_route, "route", A_LONG, 0);				// which outlet to send data out	addmess((method)avg_mode, "mode", A_LONG, 0);				// which outlet to send data out	addmess((method)inspector_open, "info", A_CANT, 0);			// bind method for opening the license window	addmess((method)avg_coef, "coef", A_FLOAT, 0);		dsp_initclass();											// Setup object's class to work with MSP	alias("tap.avg+~");										// ...for backwards compatibility	post("tap.avg~ v1.7 - Copyright © 2001 by Timothy A. Place");		// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *avg_new(t_symbol *msg, short argc, t_atom *argv){	int	sr;	float	slewTime, pollTime, outletConfig, mode;	t_avg *x = (t_avg *)newobject(avg_class);		dsp_setup((t_pxobject *)x,1);							// Create Object and 1 Inlet (last argument)	floatin((t_object *)x, 2);								// Create a floating point inlet	floatin((t_object *)x, 1);								// Create another floating point inlet    	x->avg_out = floatout(x);								// Create a floating-point Outlet	outlet_new((t_pxobject *)x, "signal");					// Create a signal Outlet 	x->metro_clock = clock_new(x, (method)clock_function);		// Create the metronome clock	sr = sys_getsr();									// Get MSP's sampling rate     	slewTime = atom_getfloatarg(0,argc,argv);				pollTime = atom_getfloatarg(1,argc,argv);				outletConfig = atom_getfloatarg(2,argc,argv);		if (msg == gensym("tap.avg+~"))	{		x->avg_mode = 1;		post("... tap.avg~ initialized in mode 1");	}	else		x->avg_mode = atom_getfloatarg(3,argc,argv);	   	x->line_slewTime = (slewTime * 0.001) * sr;				// Interpolation set by argument 1	if ( pollTime <= 0)									// Metro set by argument 2	{														x->metro_interval = 50;							// Default metro tempo in ms		x->avg_poll = 0;								// polling defaulted to off	}	else 	{		x->metro_interval = pollTime;						// Default metro tempo in ms		x->avg_poll = 1;								// polling defaults to on		clock_fdelay(x->metro_clock, 0L);					// Set clock to go off now	}	x->avg_outletConfig = outletConfig;						// Outlet Routing set by argument 3	x->avg_sampleSum = 1;								// init averaging algorithm	x->avg_sampleQuantity = 1;							// ...	x->line_destination = 0;								// Init line alogorithm	x->line_step = 0.;									// ...	x->line_result = 0;									// ...	x->avg_coef = 0.999;								// init lowpass coef	x->avg_fb = 0;										// init lowpass fb sample	return (x);										// Return the pointer}/************************************************************************************/// Methods bound to input/inlets// Method for Assistance Messagesvoid avg_assist(t_avg *x, void *b, long msg, long arg, char *dst){	if(msg==1){ 	// Inlets		switch(arg){			case 0: strcpy(dst, "(signal) To follow the envelope of"); break;			case 1: strcpy(dst, "(float) Interpolation time in ms"); break;			case 2: strcpy(dst, "(float) auto analysis interval in ms"); break;		}	}	else if(msg==2){ // Outlets		switch(arg){			case 0: strcpy(dst, "(signal) Envelope of the input"); break;			case 1: strcpy(dst, "(float) Envelope of the input"); break;		}	}}// Bang Methodvoid avg_bang(t_avg *x)	{	double f, ff, diff, step, slew = x->line_slewTime, dspState;	double sum = x->avg_sampleSum, quantity = x->avg_sampleQuantity, avg;		dspState = sys_getdspstate();	if (dspState == 0) goto bupkiss;	if (x->avg_mode != 0)		x->avg_average = sqrt(x->avg_fb);				// find the average	else	{		if (sum == 0)			{				x->avg_average = avg =0;				if (quantity == 0) goto bupkiss;				}		else			x->avg_average = avg = (sum / quantity);		// find the average	}	f = x->avg_average/* + 1*/;	if (x->avg_outletConfig != 1)		outlet_float(x->avg_out, x->avg_average);		// output the result	if ( slew != 0 )									// If interpolation is desired...	{										ff = x->line_result; 							// most recent output value		diff = f - ff;								// difference between it, and new value		step = diff / slew;							// increment per sample to interpolate linearly		x->line_destination = f;						// store final destination		x->line_step = step;							// store step size of the interpolation		x->line_samplenum = x->line_slewTime;			// needed for triggering the interpolation		x->line_samplesDone = 0;						// Reset the position in the interpolation process	}	x->avg_sampleSum = 0/*1*/;						// reset the counters		x->avg_sampleQuantity = 0/*1*/;			bupkiss:	;											// make the compiler happy}// Set interpolation timevoid avg_ft1(t_avg *x, double f){	if (f < 0) f = 0;		x->line_slewTime = (f * 0.001) * x->avg_sr; // slew time in samples (ms -> s * sample rate)}// Set modevoid avg_mode(t_avg *x, long value){	x->avg_mode = value;}// Set auto-analysis timevoid avg_ft2(t_avg *x, double f){	if (f < 0) f = 0;			if (f == 0) avg_poll(x, 0);	// Turn metro off		else x->metro_interval = f;}// Toggle On/Off the internal metrovoid avg_poll(t_avg *x, int toggle){	if (toggle != 0)			clock_fdelay(x->metro_clock, 0L);		// Set clock to go off now	else 		clock_unset(x->metro_clock);			// Remove the clock routine from the scheduler}// Selection of an outlet to send the data tovoid avg_route(t_avg *x, int outletConfig){	x->avg_outletConfig = outletConfig;}// Set feedback coefficientvoid avg_coef(t_avg *x, double coef){	x->avg_coef = coef;}// Perform (signal) Methodt_int *avg_perform(t_int *w){	t_float *in = (t_float *)(w[1]);   		// Input	t_float *out = (t_float *)(w[2]);		// Output   	t_avg *x = (t_avg *)(w[3]);			// Pointer	int n = (int)(w[4]);					// Vector Size	double inSamp, xx, sampleSum = x->avg_sampleSum, average = x->avg_average;	double step = x->line_step, result = x->line_result;	long samplesDone = x->line_samplesDone, sampleQuantity = x->avg_sampleQuantity, samplenum = x->line_samplenum;				if (x->x_obj.z_disabled) return (w+5);	if (x->avg_outletConfig == 2)	{		while (--n) 		{			inSamp = *++in;				inSamp = fabs(inSamp); 					// Absolute Value of the input			sampleSum = sampleSum + inSamp;			// Add the current sample to the sum			sampleQuantity = sampleQuantity + 1;		// Increment the sample counter			*++out = 0;		}		x->avg_sampleSum = sampleSum;				// Save the sample sum		x->avg_sampleQuantity = sampleQuantity;			// Save the sample count		return (w + 5);								// Return a pointer to the NEXT object in the DSP call chain			}	if ( x->line_slewTime == 0 )						// if no interpolation is desired	{		while (--n) 		{			inSamp = *++in;				inSamp = fabs(inSamp); 					// Absolute Value of the input					sampleSum = sampleSum + inSamp;			// Add the current sample to the sum			sampleQuantity = sampleQuantity + 1;		// Increment the sample counter			*++out = average;						// output the stored average		}		x->avg_sampleSum = sampleSum;				// Save the sample sum		x->avg_sampleQuantity = sampleQuantity;			// Save the sample count		x->line_result = average;						// store the result in case interpolation is turned on		return (w + 5);								// Return a pointer to the NEXT object in the DSP call chain			}	else											// With Linear Interpolation	{		while (--n) 		{			inSamp = *++in;				inSamp = fabs(inSamp); 					// Absolute Value of the input			sampleSum = sampleSum + inSamp;			// Add the current sample to the sum			sampleQuantity = sampleQuantity + 1;		// Increment the sample counter			if (samplesDone == samplenum) 			{				xx = result;			}			else			{				xx = result + step;				samplesDone = samplesDone + 1;				x->line_samplesDone = samplesDone;				x->line_result = result = xx;			// store the result				}			*++out = xx;							// output the interpolated samples		}						                       		x->avg_sampleSum = sampleSum;				// Save the sample sum		x->avg_sampleQuantity = sampleQuantity;			// Save the sample count		return (w + 5);								// Return a pointer to the NEXT object in the DSP call chain							}				                       }// Perform (signal) Method - RMSt_int *avg_perform2(t_int *w){	t_float *in = (t_float *)(w[1]);   		// Input	t_float *out = (t_float *)(w[2]);		// Output   	t_avg *x = (t_avg *)(w[3]);			// Pointer	int n = (int)(w[4]);					// Vector Size	double inSamp, xx, average = x->avg_average;	double step = x->line_step, result = x->line_result;	double fb = x->avg_fb, coef = x->avg_coef;	int samplesDone = x->line_samplesDone, samplenum = x->line_samplenum;				if (x->x_obj.z_disabled) return (w+5);	if (x->avg_outletConfig == 2)	{		while (--n) 		{			inSamp = *++in;						// Input			inSamp = inSamp * inSamp;				// Square					inSamp = (inSamp * (1 - coef)) + (fb * coef);	// Mean (Filter)...				fb = inSamp;									*++out = 0;		}		x->avg_fb = fb;								// Save the feedback sample		return (w + 5);								// Return a pointer to the NEXT object in the DSP call chain			}	if ( x->line_slewTime == 0 )						// if no interpolation is desired	{		while (--n) 		{			inSamp = *++in;						// Input			inSamp = inSamp * inSamp;				// Square					inSamp = (inSamp * (1 - coef)) + (fb * coef);	// Mean (Filter)...				fb = fclip(inSamp, -100000, 100000);									x->avg_fb = fb;							// Save the feedback sample				*++out = average;						// output the stored average			x->line_result = average;					// store the result in case interpolation is turned on		}		return (w + 5);								// Return a pointer to the NEXT object in the DSP call chain			}	else											// With Linear Interpolation	{		while (--n) 		{			inSamp = *++in;						// Input			inSamp = inSamp * inSamp;				// Square					inSamp = (inSamp * (1 - coef)) + (fb * coef);	// Mean (Filter)...				fb = inSamp;													x->avg_fb = fb;							// Save the feedback sample			if (samplesDone == samplenum) 			{				xx = result;				goto skipper;			}			else			{				xx = result + step;				samplesDone = samplesDone + 1;				x->line_samplesDone = samplesDone;			}	skipper:			*++out = xx;							// output the interpolated samples			x->line_result = result = xx;				// store the result									}					                       		return (w + 5);								// Return a pointer to the NEXT object in the DSP call chain	}					                       }// DSP Methodvoid avg_dsp(t_avg *x, t_signal **sp, short *count){	x->avg_fb = 0;	x->avg_sampleSum = 0;	x->avg_sampleQuantity = 0;	x->line_destination = 0;						// Re-Init values when the DSP is turned on	x->line_step = 0.0;		x->line_result = 0;	x->avg_sr = sp[0]->s_sr;		if (x->avg_mode == 0)		dsp_add(avg_perform, 4, sp[0]->s_vec-1, sp[1]->s_vec-1, x, sp[0]->s_n+1); 	else		dsp_add(avg_perform2, 4, sp[0]->s_vec-1, sp[1]->s_vec-1, x, sp[0]->s_n+1);}/************************************************************************************/// Other Functions used by object// Clock Functionvoid clock_function (t_avg *x){	long	time;	time = gettime();								//Get current time	clock_fdelay(x->metro_clock, x->metro_interval);		// Schedule another metronome tick			avg_bang(x);									// Send a bang to the bang method}// Memory De-allocationvoid avg_free(t_avg *x){	clock_unset(x->metro_clock);		// remove the clock routine from the scheduler	clock_free(x->metro_clock);		// free the clock memory	notify_free((t_object *)x);		// free the inspector memory	dsp_free((t_pxobject *)x);		// the standard MSP deallocation routine}// Utility function to keep coefficients in checkfloat fclip(float a, float b, float c){	return a < b? b: (a > c? c : a);}