// MSP External: anticlick.c// conversion to and from anticlick coordinates// T.Place and S.Moore - 6/13/2001//		v1.1 (tap 06/28/01) - implements an automated thresh/correct algorithm. //		v1.2 (tap 08/26/01) - update for Max/MSP 4. //		v1.3	(tap 12/14/01) - minor revisions#include "ext.h"					// Required for all Max External Objects#include "z_dsp.h"				// Required for all MSP External Objects	#include <math.h>#include "ext_strings.h"		// Used for the assistance stringsvoid *anticlick_class;			// Required. Global pointing to this classtypedef struct _anticlick			// Data Structure for this object{	t_pxobject x_obj;			// Required by Max (must be first)	float 	anticlick_thresh;	// current threshold	float 	anticlick_correct;	// current correction action	float 	stored_sample;		// previous input sample	int 		anticlick_mode;		// current mode	float 	size_reciprocal;	// 1 / anticlick_size	int		anticlick_size;		// desired analysis size	int     	zerox;              		// zero crossing counter-upper	int     	anticlick_i;        	// incrementer that counts to anticlick_size 	float		coef;				// lp coef	float		fb;				// feedback sample for lp	float		fb2;				// feedback sample for lp2	int		sr;				// current sampling rate	float		anticlick_amp;		// offset for the values returned by rms} t_anticlick;// Prototypes for methods: need a method for each incoming message type:t_int *anticlick_perform3(t_int *w);								// Signal Processing Methodvoid anticlick_thresh(t_anticlick *x, float value);					// Change the thresholdvoid anticlick_correct(t_anticlick *x, float value);					// Change the correctionvoid anticlick_dsp(t_anticlick *x, t_signal **sp, short *count);			// DSP Methodvoid anticlick_assist(t_anticlick *x, void *b, long m, long a, char *s);		// Assistance Methodvoid *anticlick_new(long myArg);								// New Object Creation Methodvoid anticlick_mode(t_anticlick *x, long value);						// Method to change the modefloat fclip(float a, float b, float c);								// Utility to constrain void anticlick_size(t_anticlick *x, long value);						// Change Analysis Size (in samples)void anticlick_coef(t_anticlick *x, float value);						// Change smoothing in the filtert_int *anticlick_perform1(t_int *w);t_int *anticlick_perform2(t_int *w);t_int *anticlick_perform4(t_int *w);void anticlick_adjust(t_anticlick *x, float value);void anticlick_free(t_anticlick *x);/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&anticlick_class, (method)anticlick_new, (method)anticlick_free, (short)sizeof(t_anticlick), 0L, A_DEFLONG, 0);	    						addmess((method)anticlick_dsp, "dsp", A_CANT, 0);					// Bind method "anticlick_dsp" to the DSP call from MSP	addmess((method)anticlick_assist, "assist", A_CANT, 0);				// Bind method "anticlick_assist" to assistance calls	addmess((method)anticlick_thresh, "thresh", A_FLOAT, 0);			// Bind methof "anticlick_thresh" to "thresh $1" messages	addmess((method)anticlick_correct, "correct", A_FLOAT, 0);			// ...	addmess((method)anticlick_mode, "mode", A_LONG, 0);				// 	addmess((method)anticlick_size, "size", A_LONG, 0);					// 	addmess((method)anticlick_coef, "response", A_FLOAT, 0);			// 	addfloat((method)anticlick_adjust);	addmess((method)inspector_open, "info", A_CANT, 0);				// bind method for opening the license window	dsp_initclass();												// Setup object's class to work with MSP	post("tap.anticlick~ v1.3 - Copyright © 2001 by");					// Print to the Max Window...	post("     Tim Place - Impact Center @ University of Missouri - Kansas City");	post("     Stephan Moore - iEAR Studios, Rensselaer Polytechnic Institute");}/************************************************************************************/// Object Creation Methodvoid *anticlick_new(long myArg){	t_anticlick *x = (t_anticlick *)newobject(anticlick_class);	dsp_setup((t_pxobject *)x,2);			// Create object with 2 inlets	outlet_new((t_object *)x, "signal");		// Create signal outlet	outlet_new((t_object *)x, "signal");		// Create signal outlet 	x->anticlick_size = (int)myArg;	if (x->anticlick_size == 0)		x->anticlick_size = 2000;			x->size_reciprocal = 1.0 / x->anticlick_size;	    			x->anticlick_thresh = 0;   	x->anticlick_correct = 0;	x->anticlick_amp = 1.0;		// init the amplitude sensitivity	x->stored_sample = 0;	x->anticlick_mode = 0;	x->zerox = 0;	x->anticlick_i = 0;	x->coef = 0.05;	return (x);}/************************************************************************************/// Methods bound to input/inlets// Method for Assistance Messagesvoid anticlick_assist(t_anticlick *x, void *b, long msg, long arg, char *dst){	if(msg==1){ 	// Inlets		switch(arg){			case 0: strcpy(dst, "(signal) Audio to convert to anticlick coordinates"); break;			case 1: strcpy(dst, "(signal/float) Threshold Adjustment"); break;		}	}	else if(msg==2){ // Outlets		switch(arg){			case 0: strcpy(dst, "(signal) declicked signal"); break;			case 1: strcpy(dst, "(signal) threshold"); break;		}	}}// thresh methodvoid anticlick_thresh(t_anticlick *x, float value){	x->anticlick_thresh = fclip(value, 0.0001, 100.0);}// correct methodvoid anticlick_correct(t_anticlick *x, float value){	x->anticlick_correct = fclip(value, 0.0, 0.9999999);}// modevoid anticlick_mode(t_anticlick *x, long value){	x->anticlick_mode = value;}// analysis_sizevoid anticlick_size(t_anticlick *x, long value){	x->anticlick_size = value;	x->size_reciprocal = (1.0000 / x->anticlick_size);}// smoothing filter coefficientvoid anticlick_coef(t_anticlick *x, float value){	x->coef = fclip(value, 0.00001, 0.999999);}// threshold adjustmentvoid anticlick_adjust(t_anticlick *x, float value){	x->anticlick_amp = value;}// Memory Deallocationvoid anticlick_free(t_anticlick *x){	notify_free((t_object *)x);	dsp_free((t_pxobject *)x);}// Perform (signal) Method - both inlets and both outletst_int *anticlick_perform1(t_int *w){	t_float *in, *in2, *out, *out2;	int n;	float value, value2, delta, temp, scaler;	t_anticlick *x = (t_anticlick *)(w[1]);		// Pointer		in = (t_float *)(w[2]);					// Inlet	in2 = (t_float *)(w[3]);					// Inlet2	out = (t_float *)(w[4]);					// Outlet	out2 = (t_float *)(w[5]);					// Outlet2	n = (int)(w[6]);							// Vector Size		if (x->x_obj.z_disabled) goto out;//	if (x->anticlick_mode != 0) goto correct;		// If mode is 1 (manual) skip the automatic threshold finder		value2 = (x->stored_sample < 0); 			// value2 contains whether or not the last sample was < 0		while (--n) 	{			++x->anticlick_i;											// increment the sample counter		value = *++in;												// load input sample		scaler = *++in2;		x->zerox = x->zerox + ((value2) != (value < 0)); 					// zerox increments if value2 (1 or 0 from last sample) 																// is different than value (1 or 0 of current sample)		value2 = (value < 0);											// value2 tells whether or not the last sample was < 0				temp = (((float)(x->sr * x->zerox)) / (float)x->anticlick_size)/x->sr;	// number of zero crossings expressed as a fraction of the sampling rate		if (x->anticlick_i >= x->anticlick_size)							// IF we are at the end of the analysis...		{						x->anticlick_thresh = (temp * 2.0) * scaler;					// threshold scaled according to amplitude envelope			x->anticlick_correct = (-1.0 * x->anticlick_thresh) + 1;			// correction is the inverse of the treshold			x->anticlick_thresh = fclip(x->anticlick_thresh, 0.0001, 10000.0);	// limit threshold range			x->anticlick_correct = fclip(x->anticlick_correct, 0.0, 0.99999);	// limit correction range			x->anticlick_i = x->zerox = 0;								// reset		}	}		n = (int)(w[6]);	in = (t_float *)(w[2]);		//correct:			while (--n) 	{		value = *++in;			value2 = x->stored_sample;		x->anticlick_thresh = (x->anticlick_thresh * x->coef) + (x->fb * (1 - x->coef)); x->fb = x->anticlick_thresh;		// Smoothing Filter...		x->anticlick_correct = (x->anticlick_correct * x->coef) + (x->fb2 * (1 - x->coef)); x->fb2 = x->anticlick_correct;	// Smoothing Filter...				delta = value2 - value;		if((delta > x->anticlick_thresh) || (delta < (-1 * x->anticlick_thresh)))											value = (value + (delta * x->anticlick_correct));		// algorithm to try and correct the click		x->stored_sample = value;		*++out = value;					// Output declicked sample		*++out2 = x->anticlick_thresh;		// Output current threshold	}out:    return (w+7);}// Perform (signal) Method - both inlets and 1 outlett_int *anticlick_perform2(t_int *w){	t_float *in, *in2, *out;	int n;	float value, value2, delta, temp, scaler;	t_anticlick *x = (t_anticlick *)(w[1]);		// Pointer		in = (t_float *)(w[2]);					// Inlet	in2 = (t_float *)(w[3]);					// Inlet2	out = (t_float *)(w[4]);					// Outlet	n = (int)(w[5]);							// Vector Size		if (x->x_obj.z_disabled) goto out;//	if (x->anticlick_mode != 0) goto correct;		// If mode is 1 (manual) skip the automatic threshold finder		value2 = (x->stored_sample < 0); 			// value2 contains whether or not the last sample was < 0		while (--n) 	{			++x->anticlick_i;							// increment the sample counter		value = *++in;								// load input sample		scaler = *++in2;		x->zerox = x->zerox + ((value2) != (value < 0)); 	// zerox increments if value2 (1 or 0 from last sample) 												// is different than value (1 or 0 of current sample)		value2 = (value < 0);							// value2 tells whether or not the last sample was < 0				temp = (((float)(x->sr * x->zerox)) / (float)x->anticlick_size)/x->sr;	// number of zero crossings expressed as a fraction of the sampling rate		if (x->anticlick_i >= x->anticlick_size)							// IF we are at the end of the analysis...		{						x->anticlick_thresh = (temp * 2.0) * scaler;					// threshold scaled according to amplitude envelope			x->anticlick_correct = (-1.0 * x->anticlick_thresh) + 1;			// correction is the inverse of the treshold			x->anticlick_thresh = fclip(x->anticlick_thresh, 0.0001, 10000.0);	// limit threshold range			x->anticlick_correct = fclip(x->anticlick_correct, 0.0, 0.99999);	// limit correction range			x->anticlick_i = x->zerox = 0;								// reset		}	}		n = (int)(w[5]);	in = (t_float *)(w[2]);		//correct:			while (--n) 	{		value = *++in;			value2 = x->stored_sample;		x->anticlick_thresh = (x->anticlick_thresh * x->coef) + (x->fb * (1 - x->coef)); x->fb = x->anticlick_thresh;		// Smoothing Filter...		x->anticlick_correct = (x->anticlick_correct * x->coef) + (x->fb2 * (1 - x->coef)); x->fb2 = x->anticlick_correct;	// Smoothing Filter...				delta = value2 - value;		if((delta > x->anticlick_thresh) || (delta < (-1 * x->anticlick_thresh)))											value = (value + (delta * x->anticlick_correct));		// algorithm to try and correct the click		x->stored_sample = value;		*++out = value;									// Output declicked sample	}out:    return (w+6);}// Perform (signal) Method - 1 inlet and both outletst_int *anticlick_perform3(t_int *w){	t_float *in, *out, *out2;	int n;	float value, value2, delta, temp;	t_anticlick *x = (t_anticlick *)(w[1]);		// Pointer		in = (t_float *)(w[2]);					// Inlet	out = (t_float *)(w[3]);					// Outlet	out2 = (t_float *)(w[4]);					// Outlet2	n = (int)(w[5]);							// Vector Size		if (x->x_obj.z_disabled) goto out;//	if (x->anticlick_mode != 0) goto correct;		// If mode is 1 (manual) skip the automatic threshold finder		value2 = (x->stored_sample < 0); 			// value2 contains whether or not the last sample was < 0		while (--n) 	{			++x->anticlick_i;							// increment the sample counter		value = *++in;								// load input sample		x->zerox = x->zerox + ((value2) != (value < 0)); 	// zerox increments if value2 (1 or 0 from last sample) 												// is different than value (1 or 0 of current sample)		value2 = (value < 0);							// value2 tells whether or not the last sample was < 0				temp = (((float)(x->sr * x->zerox)) / (float)x->anticlick_size)/x->sr;	// number of zero crossings expressed as a fraction of the sampling rate		if (x->anticlick_i >= x->anticlick_size)							// IF we are at the end of the analysis...		{						x->anticlick_thresh = (temp * 2.0) * x->anticlick_amp;			// threshold scaled according to amplitude envelope			x->anticlick_correct = (-1.0 * x->anticlick_thresh) + 1;			// correction is the inverse of the treshold			x->anticlick_thresh = fclip(x->anticlick_thresh, 0.0001, 10000.0);	// limit threshold range			x->anticlick_correct = fclip(x->anticlick_correct, 0.0, 0.99999);	// limit correction range			x->anticlick_i = x->zerox = 0;								// reset		}	}		n = (int)(w[5]);	in = (t_float *)(w[2]);		//correct:			while (--n) 	{		value = *++in;			value2 = x->stored_sample;		x->anticlick_thresh = (x->anticlick_thresh * x->coef) + (x->fb * (1 - x->coef)); x->fb = x->anticlick_thresh;		// Smoothing Filter...		x->anticlick_correct = (x->anticlick_correct * x->coef) + (x->fb2 * (1 - x->coef)); x->fb2 = x->anticlick_correct;	// Smoothing Filter...				delta = value2 - value;		if((delta > x->anticlick_thresh) || (delta < (-1 * x->anticlick_thresh)))											value = (value + (delta * x->anticlick_correct));		// algorithm to try and correct the click		x->stored_sample = value;		*++out = value;									// Output declicked sample		*++out2 = x->anticlick_thresh;						// Output current threshold	}out:    return (w+6);}// Perform (signal) Method - 1 inlet and 1 outlett_int *anticlick_perform4(t_int *w){	t_float *in, *out;	int n;	float value, value2, delta, temp;	t_anticlick *x = (t_anticlick *)(w[1]);	// Pointer		in = (t_float *)(w[2]);				// Inlet	out = (t_float *)(w[3]);				// Outlet	n = (int)(w[4]);						// Vector Size		if (x->x_obj.z_disabled) goto out;	if (x->anticlick_mode != 0) goto correct;	// If mode is 1 (manual) skip the automatic threshold finder		value2 = (x->stored_sample < 0); 		// value2 contains whether or not the last sample was < 0		while (--n) 	{			++x->anticlick_i;											// increment the sample counter		value = *++in;												// load input sample		x->zerox = x->zerox + ((value2) != (value < 0)); 					// zerox increments if value2 (1 or 0 from last sample) 																// is different than value (1 or 0 of current sample)		value2 = (value < 0);											// value2 tells whether or not the last sample was < 0				temp = (((float)(x->sr * x->zerox)) / (float)x->anticlick_size)/x->sr;	// number of zero crossings expressed as a fraction of the sampling rate		if (x->anticlick_i >= x->anticlick_size)							// IF we are at the end of the analysis...		{						x->anticlick_thresh = (temp * 2.0) * x->anticlick_amp;			// threshold scaled according to amplitude envelope			x->anticlick_correct = (-1.0 * x->anticlick_thresh) + 1;			// correction is the inverse of the treshold			x->anticlick_thresh = fclip(x->anticlick_thresh, 0.0001, 10000.0);	// limit threshold range			x->anticlick_correct = fclip(x->anticlick_correct, 0.0, 0.99999);	// limit correction range			x->anticlick_i = x->zerox = 0;								// reset		}	}		n = (int)(w[4]);	in = (t_float *)(w[2]);		correct:			while (--n) 	{		value = *++in;			value2 = x->stored_sample;		x->anticlick_thresh = (x->anticlick_thresh * x->coef) + (x->fb * (1 - x->coef)); x->fb = x->anticlick_thresh;		// Smoothing Filter...		x->anticlick_correct = (x->anticlick_correct * x->coef) + (x->fb2 * (1 - x->coef)); x->fb2 = x->anticlick_correct;	// Smoothing Filter...				delta = value2 - value;		if((delta > x->anticlick_thresh) || (delta < (-1 * x->anticlick_thresh)))											value = (value + (delta * x->anticlick_correct));		// algorithm to try and correct the click		x->stored_sample = value;		*++out = value;									// Output declicked sample	}out:    return (w+5);}// DSP Methodvoid anticlick_dsp(t_anticlick *x, t_signal **sp, short *count){	x->fb = 0;				// Initialize lowpass feedback	x->fb2 = 0;			// Initialize lowpass feedback #2	x->stored_sample = 0;	// Initialize stored sample for delta analysis algorithm	x->sr = sp[0]->s_sr;		// store the sampling rate   	if(count[1] && count[3]) 	// both 2nd inlet and 2nd outlet are connected      	 	dsp_add(anticlick_perform1, 6, x, sp[0]->s_vec-1, sp[1]->s_vec-1, sp[2]->s_vec-1, sp[3]->s_vec-1, sp[0]->s_n + 1);	else if(count[1]) 		// 2nd inlet, not 2nd outlet       		dsp_add(anticlick_perform2, 5, x, sp[0]->s_vec-1, sp[1]->s_vec-1, sp[2]->s_vec-1, sp[0]->s_n + 1);	else if(count[3]) 		// 2nd outlet, not 2nd inlet      	 	dsp_add(anticlick_perform3, 5, x, sp[0]->s_vec-1, sp[2]->s_vec-1, sp[3]->s_vec-1, sp[0]->s_n + 1);	else 					// 1st inlet and 1st outlet only		dsp_add(anticlick_perform4, 4, x, sp[0]->s_vec-1, sp[2]->s_vec-1, sp[0]->s_n + 1);}/************************************************************************************/// Other Functions used by object// clipping utilityfloat fclip(float a, float b, float c){	return a < b? b: (a > c? c : a);}