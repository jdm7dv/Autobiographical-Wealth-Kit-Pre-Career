// MSP External: split~.c// An MSP complement to the MAX split object// T.Place - September 2000//		v1.2 (08/27/01) - update for Max/MSP 4//		v1.3 (12/14/01) - minor revisions#include "ext.h"			// Required for all Max External Objects#include "z_dsp.h"		// Required for all MSP External Objects			#include "ext_strings.h"		// Used for the assistance stringsvoid *split_class;		// Required. Global pointing to this classtypedef struct _split	// Data Structure for this object{    t_pxobject x_obj;		// Header;  Must always be the first field; used by MSP	float s_low;		// low value from the typed in argument	float s_high;		// high value from the typed in argument	short s_connect[6];	// array of inlet and outlet connections} t_split;// Prototypes for methods: need a method for each incoming message typevoid *split_new(float low, float high);						// New Object Creation Methodt_int *split_perform1(t_int *w);						// An MSP Perform (signal) Methodt_int *split_perform3(t_int *w);						// An MSP Perform (signal) Methodvoid split_dsp(t_split *x, t_signal **sp, short *count);		// DSP Methodvoid split_assist(t_split *x, void *b, long m, long a, char *s);	// Assistance Methodvoid split_free(t_split *x);void split_int(t_split *x, long n);void split_float(t_split *x, double val);/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&split_class, (method)split_new, (method)split_free, (short)sizeof(t_split), 0L, A_DEFFLOAT, A_DEFFLOAT, 0);	addmess((method)split_dsp, "dsp", A_CANT, 0);					// Bind method "split_dsp" to the DSP call from MSP	addmess((method)split_assist, "assist", A_CANT, 0);				// Bind method "split_assist" to assistance calls	addfloat((method)split_float);									addint((method)split_int);										addmess((method)inspector_open, "info", A_CANT, 0);				// bind method for opening the license window		dsp_initclass();												// Setup object's class to work with MSP	alias("split~");												// ...for backwards compatibility	post("tap.split~ v1.3 - Copyright © 2000-2001 by Timothy A. Place");	// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *split_new(float low, float high){	t_split *x = (t_split *)newobject(split_class);	dsp_setup((t_pxobject *)x, 3);				// Create Object with 3 Inlets (input, low-test, high-test)     	outlet_new((t_object *)x, "signal");			// Create a signal outlet: values w/in range  	outlet_new((t_object *)x, "signal");			// Create a signal outlet: values out-of-range 	outlet_new((t_object *)x, "signal");			// Create a signal outlet: true/false 	x->s_low = low;							// Init the typed in arguments...	x->s_high = high;				return x;								// Return pointer}/************************************************************************************/// Methods bound to input/inlets// Method for Assistance Messagesvoid split_assist(t_split *x, void *b, long msg, long arg, char *dst){	if(msg==1){ 	// Inlets		switch(arg){			case 0: strcpy(dst, "(signal) Value to be sent to one of the 2 outlets"); break;			case 1: strcpy(dst, "(signal/float) Set lower limit for left outlet"); break;			case 2: strcpy(dst, "(signal/float) Set upper limit for left outlet"); break;		}	}	else if(msg==2){ // Outlets		switch(arg){			case 0: strcpy(dst, "(signal) Input if within limits"); break;			case 1: strcpy(dst, "(signal) Input if not within limits"); break;			case 2: strcpy(dst, "(signal) Comparison result (1 or 0)"); break;		}	}}// Method for Int inputvoid split_int(t_split *x, long n){	split_float(x,(double)n);	// cast as double-precision-float and pass off the data}// Method for float inputvoid split_float(t_split *x, double val){	switch (x->x_obj.z_in) 	{		case 1:			x->s_low = val;			break;		case 2:			x->s_high = val;			break;	}}// Memory Deallocationvoid split_free(t_split *x){	notify_free((t_object *)x);	dsp_free((t_pxobject *)x);}// Perform (signal) Method for 3 input signalst_int *split_perform3(t_int *w){	t_float *in1 = (t_float *)(w[1]);	// Input 1	t_float *in2 = (t_float *)(w[2]);	// Input 2	t_float *in3 = (t_float *)(w[3]);	// Input 3    	t_float *out1 = (t_float *)(w[4]);	// Output 1	t_float *out2 = (t_float *)(w[5]);	// Output 2	t_float *out3 = (t_float *)(w[6]);	// Output 3       	t_split *x = (t_split *)(w[7]);		//  Object Pointer	int n = (int)(w[8]);				// "Vector" Size	float value, low, high;				//  Variable for temporary storage  	low = x->s_connect[1]? *(t_float *)(w[2]) : x->s_low;	high = x->s_connect[2]? *(t_float *)(w[3]) : x->s_high; 	while (n--)	{		value = *in1++;		if ((value >= low) && (value <= high)) 		{				*out1++ = value;			*out2++ = 0;			*out3++ = 1;		}		else//if ((value < low) || (value > high))		{			*out1++ = 0;			*out2++ = value;			*out3++ = 0; 	 			}												}	return (w + 9);					// return pointer to NEXT object in dsp chain}// Perform (signal) Method for 1 input signalt_int *split_perform1(t_int *w){	t_float *in1 = (t_float *)(w[1]);	// Input 1	t_float *out1 = (t_float *)(w[2]);	// Output 1	t_float *out2 = (t_float *)(w[3]);	// Output 2	t_float *out3 = (t_float *)(w[4]);	// Output 3       	t_split *x = (t_split *)(w[5]);		//  Object Pointer	int n = (int)(w[6]);				// "Vector" Size	float value;					//  Variable for temporary storage  	while (n--)	{		value = *in1++;		if ((value >= x->s_low) && (value <= x->s_high)) 		{				*out1++ = value;			*out2++ = 0;			*out3++ = 1;		}		else//if ((value < x->s_low) || (value > x->s_high))		{			*out1++ = 0;			*out2++ = value;			*out3++ = 0; 	 			}												}    return (w + 7);					// return pointer to NEXT object in dsp chain}// DSP Methodvoid split_dsp(t_split *x, t_signal **sp, short *count){	short i;		for(i=0; i<6; i++)		x->s_connect[i] = count[i];	if (count[1] || count[2])	// IF the 2nd or 3rd inlet has a signal connected to it...		dsp_add(split_perform3, 8, sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec,			sp[3]->s_vec, sp[4]->s_vec, sp[5]->s_vec, x, sp[0]->s_n);		else			dsp_add(split_perform1, 6, sp[0]->s_vec, 			sp[3]->s_vec, sp[4]->s_vec, sp[5]->s_vec, x, sp[0]->s_n);	}