//  Copyright 1997-1998 Regents of the University of California.//  Permission is granted to use this software for any noncommercial purpose.//  For commercial licensing contact the UCSD Technology Transfer Office.////  UC MAKES NO WARRANTY, EXPRESS OR IMPLIED, IN CONNECTION WITH THIS SOFTWARE!////  Written by Miller Puckette (msp@ucsd.edu)//  bonk~////  Mac port (bink~) by Ichiro Fujinaga (ich@jhu.edu) started 99/03/19//  Mac port (tap.bink~) rounded off the port and prepared for release by Timothy Place (tap@sp-intermedia.com) 05/2001//  		Version 1.2 - Updated for Max/MSP 4 (09/2001) //		Version 1.3 - minor revisions (12/14/2001)//		Things needing to be done://		change perform routine changed to pre-inc/dec to be more efficient on PPC//		changed initialize args to A_GIMME and made a symbol automatically load a template file//		file I/O needs to be rewritten to to take advantage of Max4 and protect itself from interupt level calls (started)#include "tap.bink.h"#include "ext_common.h"#include "ext_strings.h"#include "ext_path.h"#define FILE_DIALOG 1#define FILE_NAMED 2void *bonk_class;				// Required. Global pointing to this classtypedef struct _bonk			// Data Structure for this object{	t_pxobject x_obj;			//	t_outlet *x_outlet;			// Raw Output Outlet	t_outlet *x_cookedout;		// Cooked Output Outlet	t_clock *x_clock;			//	t_hist x_hist[NFILTERS];		//	t_template *x_template;		//	int x_down2;				//	int x_ntemplate;			//	float *x_inbuf;				//	int x_infill;				//	int x_countdown;			//	int x_period;				//	int x_willattack;			//	float x_hithresh;			//	float x_lothresh;			//	int x_masktime;			//	float x_maskdecay;			//	int x_learn;				//	int x_lastlearn;				//	double x_learndebounce;		// used only in "learn" mode	int x_learncount;	    		// countup for "learn" mode	float x_debouncedecay;		//	float x_minvel; 	    			// minimum velocity we output	float x_debouncevel;			//	t_float x_val;				//	Symbol *bink_fn;			// file name	char bink_read;				// flag for read method (dialog or defined)	short bink_vol;				// file path} t_bonk;// Prototypes for methods: need a method for each incoming message type:void *bonk_new(t_floatarg fperiod, t_floatarg fdown2);			// void bink_assist(t_bonk *x, void *b, long m, long a, char *s);		// void bonk_dsp(t_bonk *x, t_signal **sp, short *count);			// void bonk_thresh(t_bonk *x, t_floatarg f1, t_floatarg f2);		// void bonk_mask(t_bonk *x, t_floatarg f1, t_floatarg f2);			// void bonk_debounce(t_bonk *x, t_floatarg f1);					// void bonk_minvel(t_bonk *x, t_floatarg f);					// void bonk_print(t_bonk *x, t_floatarg f);						// void bonk_learn(t_bonk *x, t_floatarg f);						// void bonk_forget(t_bonk *x);								// Empty the stored templatevoid bonk_bang(t_bonk *x);								// void bonk_setupkernels(void);								// void bonk_read(t_bonk *x, t_symbol *s);						// Open a saved templatevoid bonk_write(t_bonk *x, t_symbol *s);						// Write a template to diskvoid *bonk_tick(t_bonk *x);								// void bink_free(t_bonk *x);t_int *bonk_perform(t_int *w);void bonk_doit(t_bonk *x);void bink_read(t_bonk *x, t_symbol *s);void bink_doread(t_bonk *x);void bink_fromfile(t_bonk *x, char *name, short vol, OSType type);void bink_finished_reading(t_bonk *x);/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&bonk_class, (method)bonk_new, (method)bink_free, (short)sizeof(t_bonk), 0L, A_DEFFLOAT, 0);    	    					addmess((method)bonk_dsp, "dsp", A_CANT, 0);				// Method Bindings....	addmess((method)bink_assist,"assist",A_CANT,0);	addbang((method)bonk_bang);	addmess((method)bonk_thresh, "thresh", A_FLOAT, A_FLOAT, 0);	addmess((method)bonk_mask, "mask", A_FLOAT, A_FLOAT, 0);	addmess((method)bonk_debounce, "debounce", A_FLOAT, 0);	addmess((method)bonk_minvel, "minvel", A_FLOAT, 0);	addmess((method)bonk_print, "print", A_DEFFLOAT, 0);	addmess((method)bonk_learn, "learn", A_FLOAT, 0);	addmess((method)bonk_forget, "forget", 0);	addmess((method)bonk_read, "read", A_DEFSYM, 0);	addmess((method)bonk_write, "write", A_DEFSYM, 0);		addmess((method)inspector_open, "info", A_CANT, 0);			// bind method for opening the license window		bonk_setupkernels();									// 	dsp_initclass();											// Setup object's class to work with MSP	alias("bink~");											// ...for backwards compatibility	post("tap.bink~ v1.3 - port by Ichiro Fujinaga with additions by Timothy Place");		post("     Original code - bonk~ - by Miller Puckett");}/************************************************************************************/// Object Creation Methodvoid *bonk_new(t_floatarg fperiod, t_floatarg fdown2){	int i;	t_hist *h;	t_bonk *x = (t_bonk *)pd_new(bonk_class);	// Pointer	float *fp;	int period = fperiod;	int down2 = (fdown2 != 0);	dsp_setup((t_pxobject *)x, 1);				// Create out object with 1 inlet	x->x_cookedout = outlet_new(&x->x_obj, "list");	x->x_outlet = outlet_new(&x->x_obj, "list");	x->x_clock = clock_new(x, bonk_tick);	for (i = 0, h = x->x_hist; i--; h++)		// Set defaults....		h->h_power = h->h_mask = h->h_before = 0, h->h_countup = 0;	x->x_template = (t_template *)getbytes(0);	x->x_ntemplate = 0;	x->x_inbuf = (float *)getbytes(NPOINTS * sizeof(float) * 10);	for (i = NPOINTS, fp = x->x_inbuf; i--; fp++)     		*fp = 0;	x->x_infill = 0;	x->x_countdown = 0;	if (!period) 		period = NPOINTS/2;	x->x_period = period;	x->x_willattack = 0;	x->x_down2 = down2;	x->x_hithresh = DEFHITHRESH;	x->x_lothresh = DEFLOTHRESH;	x->x_masktime = DEFMASKTIME;	x->x_maskdecay = DEFMASKDECAY;	x->x_learn = 0;	x->x_lastlearn = 0;	x->x_learndebounce = clock_getsystime();	x->x_learndebounce = 0;	x->x_learncount = 0;	x->x_debouncedecay = DEFDEBOUNCEDECAY;	x->x_minvel = DEFMINVEL;	x->x_debouncevel = 0;	return (x);						// Return the object's pointer}/************************************************************************************/// Methods bound to input/inlets// Assistance Messagesvoid bink_assist(t_bonk *x, void *b, long msg, long arg, char *dst){	if(msg==1) 	// Inlets		strcpy(dst, "(signal) To be analyzed");			else if(msg==2){ // Outlets		switch(arg){			case 0: strcpy(dst, "(list) Raw Output"); break;			case 1: strcpy(dst, "(signal) Cooked Output"); break;		}	}}// Memory Deallocationvoid bink_free(t_bonk *x){	notify_free((t_object *)x);	dsp_free((t_pxobject *)x);}// The Massive Tick Method (compares input to the learned templates)void *bonk_tick(t_bonk *x){#if 1	t_atom at[NFILTERS], *ap, at2[2];	int i, j;	t_hist *h;	float powerout[NFILTERS], *pp, vel = 0;	float tmp[NFILTERS];	float *fp;	t_template *tp;	int nfit;	static FEATURE database[200];	for (i = NFILTERS, pp = powerout, h = x->x_hist; i--; pp++, h++)	{		float pow = h->h_mask /* - h->h_before */;		if (pow > 0) vel += (*pp = 35.f * qrsqrt(qrsqrt(pow)));		else *pp = 0;	}	if (vel < x->x_debouncevel || vel < x->x_minvel) return (NULL);	x->x_debouncevel = vel;	if (x->x_learn)	{    		double lasttime = x->x_learndebounce;    		double msec = clock_gettimesince(lasttime);    		if (!(x->x_ntemplate) || (msec > 200))    		{    	    		int countup = x->x_learncount, ntemplate = x->x_ntemplate;    	    		float norm;     	    	// normalize to 100 	    			for (i = NFILTERS, norm = 0, pp = powerout; i--; pp++)     	    			norm += *pp * *pp;    	    		if (norm < 1.0e-15) norm = 1.0e-15;    	    		norm = 100.f * qrsqrt(norm);    	    		/* check if this is the first strike for a new template */    	    		if (!countup)    	    		{    	    			int oldn = ntemplate;    	    			x->x_ntemplate = ntemplate = oldn + 1;    	    			x->x_template = (t_template *)t_resizebytes((char *)x->x_template,    	    	   		 oldn * sizeof(x->x_template[0]), ntemplate * sizeof(x->x_template[0]));				for (i = NFILTERS, fp = x->x_template[oldn].t_amp, pp = powerout;  i--; fp++, pp++)					*fp = *pp * norm;				makeFeatureVector(database, x->x_template[oldn].t_amp, NFILTERS, oldn * x->x_learn, oldn);    	   		 }    	   		 else // averaging (prototype learning model)    	   		{				for (i = NFILTERS, fp = tmp, pp = powerout; i--; fp++, pp++)					*fp = *pp * norm;				makeFeatureVector(database, tmp, NFILTERS, (x->x_ntemplate - 1) * x->x_learn + countup, (x->x_ntemplate - 1));   	    				for (i = NFILTERS, fp = x->x_template[ntemplate - 1].t_amp, pp = powerout;  i--; fp++, pp++)					*fp = (countup * *fp + *pp * norm) /(countup + 1.0f);    	    		}    	    		countup++;			if (countup == x->x_learn) countup = 0;			post("Count: %d", countup);    	    		x->x_learncount = countup;    			}		else return (NULL);    		}	x->x_learndebounce = clock_getsystime();	if (x->x_ntemplate)	{		float bestfit = 0;		#if 0    	    /*this is a more sophisticated test that seems to work no    	    	better than the straight dot-product test below: */		nfit = -1;		for (i = 0, tp = x->x_template; i < x->x_ntemplate; tp++, i++)		{			float dotprod = 0, wantsqnorm = 0, gotsqnorm = 0, score;    	    		for (j = NFILTERS, fp = tp->t_amp, pp = powerout, h = x->x_hist; j--; fp++, pp++, h++)			{				float want = *fp, got = *pp;				float mask = h->h_mask, before = h->h_before;				float weight;				if (mask > before && before >= 0)					weight = (mask - before)/mask;				else weight = 0;				dotprod += weight * want * got;				wantsqnorm += weight * want * want;				gotsqnorm += weight * got * got;	    		}			if (wantsqnorm > 0 && gotsqnorm > 0)				score = dotprod * dotprod / (wantsqnorm * gotsqnorm);			else score = 0;			if (score > bestfit)			{				bestfit = score;				nfit = i;			}		}		if (nfit < 0)		{			post("bonk: ouch");			nfit = 0;		}========================				for (i = 0, tp = x->x_template; i < x->x_ntemplate; tp++, i++)		{			float dotprod = 0;			for (j = NFILTERS, fp = tp->t_amp, pp = powerout; j--; fp++, pp++) 				dotprod += *fp * *pp;			if (dotprod >= bestfit)			{				bestfit = dotprod;				nfit = i;			}		}		if (nfit < 0) post("bonk_tick");#endif#if 1		float newbestfit = 0;		int newfit = -1;		static float weights[] = {1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.};		nfit = -1;		makeFeatureVector(database, powerout, NFILTERS, 499, -1);		newfit = find_nn(&database[499], -1, database, x->x_ntemplate * x->x_lastlearn, weights, x->x_lastlearn / 2);		for (i = 0, tp = x->x_template; i < x->x_ntemplate; tp++, i++)		{			float dotprod = 0, city_block = 0;			for (j = NFILTERS, fp = tp->t_amp, pp = powerout; j--; fp++, pp++)				dotprod += *fp * *pp;			if (dotprod >= bestfit)			{				bestfit = dotprod;				nfit = i;			}   		}		if (nfit < 0) post("bonk_tick");#endif	}	else nfit = 0;	at2[0].a_type = A_FLOAT;	at2[0].a_w.w_float = nfit;	at2[1].a_type = A_FLOAT;	at2[1].a_w.w_float = vel;	outlet_list(x->x_cookedout, 0L, 2, at2);	for (i = 0, ap = at, pp = powerout; i < NFILTERS; i++, ap++, pp++)	{		ap->a_type = A_FLOAT;		ap->a_w.w_float = *pp;	}	outlet_list(x->x_outlet, 0L, NFILTERS, at);#endif	return(NULL);}//void bonk_doit(t_bonk *x){	int i, j;	t_filterkernel *k;	t_hist *h;	float growth = 0; 	for (i = NFILTERS, k = bonk_filterkernels, h = x->x_hist; i--; k++, h++)	{		float rsum = 0, isum = 0, *fp1, *fp2, power, maskpow = h->h_mask;		int countup = h->h_countup;		for (fp1 = x->x_inbuf + k->k_onset, fp2 = k->k_stuff, j = k->k_npoints; j--;)		{			float g = *fp1++;			rsum += g * *fp2++;			isum += g * *fp2++;		}		power = rsum * rsum + isum * isum;		if (!x->x_willattack) h->h_before = maskpow;	    	if (power > maskpow)			growth += power/(maskpow + 1.0e-15) - 1.f;		if (!x->x_willattack && countup >= x->x_masktime)			maskpow *= x->x_maskdecay;		if (power > maskpow)		{			maskpow = power;			countup = 0;		}		countup++;		h->h_countup = countup;		h->h_mask = maskpow;		h->h_power = power;	}	if (x->x_willattack > 4)		// if it takes more than 4 analyses for the energy to stop growing,		x->x_willattack = 0; 		// forget it; we would rather miss the note than report it late.	else if (x->x_willattack)	{		if (growth < x->x_lothresh)		{			clock_delay(x->x_clock, 0);			x->x_willattack = 0;		}		else x->x_willattack++;	}	else if (growth > x->x_hithresh)	{		x->x_willattack = 1;		for (i = NFILTERS, h = x->x_hist; i--; h++)			h->h_mask = h->h_power, h->h_countup = 0;	}    	x->x_debouncevel *= x->x_debouncedecay;	// shift the input buffer and update counters	if (x->x_period > NPOINTS) x->x_countdown = x->x_period - NPOINTS;	else x->x_countdown = 0;	if (x->x_period < NPOINTS)	{		int overlap = NPOINTS - x->x_period;		float *fp1, *fp2;		for (i = overlap, fp1 = x->x_inbuf, fp2 = fp1 + x->x_period; i--;) *fp1++ = *fp2++;			x->x_infill = overlap;	}	else x->x_infill = 0;}// Set thresholdsvoid bonk_thresh(t_bonk *x, t_floatarg f1, t_floatarg f2){	if (f1 > f2)		post("bonk: warning: low threshold greater than hi threshold");	x->x_lothresh = f1;	x->x_hithresh = f2;}//void bonk_mask(t_bonk *x, t_floatarg f1, t_floatarg f2){	int ticks = f1;	if (ticks < 0) ticks = 0;	if (f2 < 0) f2 = 0;	else if (f2 > 1) f2 = 1;	x->x_masktime = ticks;	x->x_maskdecay = f2;}//void bonk_debounce(t_bonk *x, t_floatarg f1){	if (f1 < 0) f1 = 0;	else if (f1 > 1) f1 = 1;	x->x_debouncedecay = f1;}// Set minimum velocityvoid bonk_minvel(t_bonk *x, t_floatarg f){	if (f < 0) f = 0; 	x->x_minvel = f;}//void bonk_print(t_bonk *x, t_floatarg f){	int i;	if (f == 0)	{		post("thresh %f %f", x->x_lothresh, x->x_hithresh);		post("mask %d %f", x->x_masktime, x->x_maskdecay);		post("debounce %f", x->x_debouncedecay);		post("minvel %f", x->x_minvel);		if (x->x_ntemplate)		{			post("templates:");			for (i = 0; i < x->x_ntemplate; i++)				post("%2d \					%5.2f %5.2f %5.2f %5.2f %5.2f %5.2f %5.2f %5.2f %5.2f %5.2f %5.2f", i,					x->x_template[i].t_amp[0], x->x_template[i].t_amp[1], x->x_template[i].t_amp[2],					x->x_template[i].t_amp[3], x->x_template[i].t_amp[4], x->x_template[i].t_amp[5],					x->x_template[i].t_amp[6], x->x_template[i].t_amp[7], x->x_template[i].t_amp[8],					x->x_template[i].t_amp[9], x->x_template[i].t_amp[10]);		}		else post("no templates");		if (x->x_learn) post("learn mode");	}	if (f != 0)	{		int i;		t_hist *h;		for (i = NFILTERS, h = x->x_hist; i--; h++) 		post("pow %f mask %f before %f count %d", h->h_power, h->h_mask, h->h_before, h->h_countup);	}}// Set Learn Modevoid bonk_learn(t_bonk *x, t_floatarg f){	int n = f;	if (n < 0) n = 0;	if (n)	{		x->x_template = (t_template *)t_resizebytes((char *)x->x_template, x->x_ntemplate * sizeof(x->x_template[0]), 0);		x->x_ntemplate = 0;	}	x->x_lastlearn = x->x_learn;	x->x_learn = n;	x->x_learncount = 0;}// Forget Templatesvoid bonk_forget(t_bonk *x){	int ntemplate = x->x_ntemplate, newn = ntemplate-1;	if (ntemplate)	{		x->x_template = (t_template *)t_resizebytes((char *)x->x_template, x->x_ntemplate * sizeof(x->x_template[0]), newn * sizeof(x->x_template[0]));		x->x_ntemplate = newn;	}	x->x_learncount = 0;}// bang Methodvoid bonk_bang(t_bonk *x){	t_atom at[NFILTERS];	int i;	for (i = 0; i < NFILTERS; i++)	{		at[i].a_type = A_FLOAT;		at[i].a_w.w_float = 100 * qrsqrt(qrsqrt(x->x_hist[i].h_power));	}	outlet_list(x->x_outlet, 0L, NFILTERS, at);}//void bonk_setupkernels(void){	int i, j;	float *fp;	for (i = 0; i < NFILTERS; i++)	{		int npoints = bonk_filters[i].s_npoints;		float freq = bonk_filters[i].s_freq;		float normalize = 2.8284f / npoints;		float phaseinc = (2.f * 3.14159f) / npoints;		bonk_filterkernels[i].k_npoints = npoints;		bonk_filterkernels[i].k_onset = (NPOINTS/2) - (npoints/2);		bonk_filterkernels[i].k_stuff =		(float *)getbytes(2 * sizeof(float) * npoints);		for (fp = bonk_filterkernels[i].k_stuff, j = npoints; j--;)		{			float phase = j * phaseinc;			float window = normalize * (0.5f - 0.5f * cos(phase));			*fp++ = window * cos(freq * phase);			*fp++ = window * sin(freq * phase);		}	}}// Read method to defer the actual file handling so it doesn't happen at interupt levelvoid bink_read(t_bonk *x, t_symbol *s){	if (s->s_name[0]){		x->bink_read = FILE_NAMED;	// set flag		x->bink_fn = s;				// file name = symbol typed in	}	else		x->bink_read = FILE_DIALOG;	// set flag	defer(x, (method)bink_doread, 0, 0, 0);}// Actually figure out how the user is choosing to define the file and set itvoid bink_doread(t_bonk *x){	short vol,numtypes = 2;	long i;	long type;	char name[256];	name[0] = 0;		if (x->bink_read==FILE_DIALOG) {			if (!open_dialog(name, &vol, &type, NULL, -1)) {			bink_fromfile(x,name,vol,type);			x->bink_fn = gensym(name);			x->bink_vol = vol;			bink_finished_reading(x);		}	}	else if(x->bink_read == FILE_NAMED){		strcpy(name, x->bink_fn->s_name);		// 'de-Symbol' the file name		if (!locatefile_extended (name, &x->bink_vol, &type, NULL, -1)){			bink_fromfile(x, name, x->bink_vol, type);			bink_finished_reading(x);		}		else{			error("tap.bink~: can't read file %s", x->bink_fn->s_name);			x->bink_fn = gensym(" ");		}	}}// Actually read the filevoid bink_fromfile(t_bonk *x, char *name, short vol, OSType type){	short err;	FILE_REF fd;	long i = 1;	long listLength = 0, listCounter = 0;	short dataPerFrame;	long numberOfFrames;	float frameRate;	float length;	float test;		// temp. storage	long test2;	// temp. storage	char test3[4];	// temp. storage		err = path_openfile(name, vol, &fd, READ_PERM);	if (err){		error("tap.bink~: error %d opening file %s", err, name);		return;	}	//   	outlet_anything(x->lpc_importOutlet, gensym("clear"), 0, NIL); 	//clear the coll	{		long bytecount = 4;		for (i=0; i<=8; i++){			if(listLength == 0)	// If at the first element, insert an index number first			{//				SETLONG(x->lpc_outList+listLength,listCounter);				listLength++;			}						if(listCounter == 0)	// HEADER			{				if(listLength <= 4)				{					FSRead(fd, &bytecount, &test2);//					SETLONG(x->lpc_outList+listLength ,test2);	// put the number at the current index					if(listLength == 4)						dataPerFrame = test2;					listLength++;				}				else if(listLength <= 7)				{					FSRead(fd, &bytecount, &test);//					SETFLOAT(x->lpc_outList+listLength, test);	// put the number at the current index					if (listLength == 5)						length = test;					else if (listLength == 7){						frameRate = test;						numberOfFrames = (long)(frameRate * length);						post("tap.lpc~ importing %i frames of lp analysis", numberOfFrames);					}						listLength++;									}				else if(listLength == 8)				{					bytecount = 2;					for (i=0; i<4; i++){						FSRead(fd, &bytecount, &test3);//						SETSYM(x->lpc_outList+listLength, " "/*test3*/);	// put the string at the current index						listLength++;						}						bytecount = 4;				}				else				{//					outlet_list(x->lpc_importOutlet, 0L, listLength, x->lpc_outList); //output data					listLength = 0;	// reset length counter					listCounter++;	// advance to the next index					//					SETLONG(x->lpc_outList+listLength,listCounter);					listLength++;//					SETFLOAT(x->lpc_outList+listLength,test);	// put the number at the current index					listLength++;										}				}		}			for (i=0;i < (numberOfFrames * dataPerFrame); i++){	// DATA			FSRead(fd, &bytecount, &test);			if(listLength <= dataPerFrame)			{//				SETFLOAT(x->lpc_outList+listLength,test);	// put the number at the current index				listLength++;									}			else			{//				outlet_list(x->lpc_importOutlet, 0L, listLength, x->lpc_outList); //output data				listLength = 0;	// reset length counter				listCounter++;	// advance to the next index//				SETLONG(x->lpc_outList+listLength,listCounter);				listLength++;//				SETFLOAT(x->lpc_outList+listLength,test);	// put the number at the current index				listLength++;									}								}	}			FSClose(fd);	// FSClose refers to the files reference number}  // Let the user know the file reading is donevoid bink_finished_reading(t_bonk *x){	post("tap.bink~ finished reading");}#define BUFSIZE (80)// Read a file from diskvoid bonk_read(t_bonk *x, t_symbol *s){	short vol, fRefNum;	int ret, whitespace, count;	char buf[BUFSIZE];	char fname[256];	float vec[NFILTERS];	int i, ntemplate = 0;	float *fp, *fp2;	{		OSType dstType;				if (open_dialog(fname, &vol, &dstType, 0L, 0) != 0)			return;		s->s_name = fname;	}	#if 0	else if (locatefile(s->s_name, &vol, &bin))	{		post("%s: open failed", s->s_name);		return;	}#endif	if (FSOpen(c2pstr(s->s_name), vol, &fRefNum) != 0)	{		post("%s: open failed1", s->s_name);		return;	}	x->x_template = (t_template *)t_resizebytes((char *)x->x_template, x->x_ntemplate * sizeof(t_template), 0);	while (1)	{		long bytecount = 1;		i = 0;		ret = 1;				whitespace = 1;		count = 0;		fp = vec;		while (bytecount && i < BUFSIZE)		{			FSRead(fRefNum, &bytecount, &buf[i]);			ret = bytecount;			if ((buf[i] == '\t' || buf[i] == ' ' || buf[i] == ';') && !whitespace)			{				whitespace = 1;				sscanf(buf, "%f", fp++);				if (buf[i] == ';')				bytecount = 0;				i = -1;			}			else if (whitespace && buf[i] != ' ' && buf[i] != '\r')			{			count++;			whitespace = 0;			}			i++;		}		if (count < NFILTERS) goto nomore;		x->x_template = (t_template *)t_resizebytes((char *)x->x_template, ntemplate * sizeof(t_template), (ntemplate + 1) * sizeof(t_template));		for (i = NFILTERS, fp = vec, fp2 = x->x_template[ntemplate].t_amp; i--;)			*fp2++ = *fp++;		ntemplate++;	}nomore:	post("bonk: read %d templates", ntemplate);	x->x_ntemplate = ntemplate;	FSClose(fRefNum); }// Save a template to diskvoid bonk_write(t_bonk *x, t_symbol *s){	char fname[256] = "template";	char buf[40];	short i,  vol, fRefNum;	float *fp;	unsigned char *str;		int ret, ntemplate = x->x_ntemplate;	t_template *tp = x->x_template;	{		if (saveas_dialog(fname, &vol, 0) != 0)			return;		s->s_name = fname;		post("%s vol %d", s->s_name, vol);		str = c2pstr(s->s_name);		ret = Create(str, vol, 'max2', 'TEXT');	}#if 0		else if (locatefile(s->s_name, &vol, &bin))	{		post("%s: open failed", s->s_name);		vol = defvolume();		post("Vol: %d", vol);		str = c2pstr(s->s_name);		ret = Create(str, vol, 'max2', 'TEXT');		post("Ret: %d", ret);	}	else		str = c2pstr(s->s_name);  // write over existing file#endif			if (FSOpen(str, vol, &fRefNum) != 0)	{		post("%s: open failed1", s->s_name);		return;	}	post("OPENED for writing");	for (; ntemplate--; tp++)	{    	long count;		for (i = NFILTERS, fp = tp->t_amp; i--; fp++)		{			count = 12;			ret = sprintf(buf, " %10.4f", *fp);			FSWrite(fRefNum, &count, buf);		}		count = 2;		sprintf(buf, ";\r");		FSWrite(fRefNum, &count, buf);	}	post("bonk: wrote %d templates", x->x_ntemplate);	FSClose(fRefNum);}// Perform (signal) Methodt_int *bonk_perform(t_int *w){	t_float *in1 = (t_float *)(w[1]);	t_bonk *x = (t_bonk *)(w[2]);	int n = (int)(w[3]);	int down2 = x->x_down2;	if (x->x_countdown > 0) x->x_countdown -= (down2? (n>>1) : n);	else	{		int infill = x->x_infill;		float *fp = x->x_inbuf + infill;		if (down2)		{			int nreal = n>>1;			infill += nreal;			while (nreal--)	  		{				*fp++ = *in1;				in1 += 2;			}		}		else		{			infill += n;			if (infill > NPOINTS)   // added IF			{		 	//	post("ERROR!! %d", infill);		  		infill = NPOINTS;			}			else				while (n--) 					*fp++ = *in1++;		}		x->x_infill = infill; 		if (infill == NPOINTS) 		bonk_doit(x);	} 	return (w+4);}// DSP Methodvoid bonk_dsp(t_bonk *x, t_signal **sp, short *count){//	post("Count %d", count[0]);	x->x_period = sys_getblksize();//	post("Period size: %d", x->x_period);	dsp_add(bonk_perform, 3, sp[0]->s_vec, x, sp[0]->s_n);}