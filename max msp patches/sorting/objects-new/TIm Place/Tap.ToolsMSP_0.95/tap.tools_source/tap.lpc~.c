//  tap.lpc//  object to import a Csound LPC analysis for Max/MSP//  by Timothy A. Place © 2001 - 08/29/01//		v1.1 (12/14/01) - minor revisions#include "ext.h"#include "z_dsp.h"#include "ext_common.h"#include "ext_strings.h"#include "ext_path.h"#define FILE_DIALOG 1#define FILE_NAMED 2void *lpc_class;					// Required. Global pointing to this classtypedef struct _lpc				// Data Structure for this object{	t_pxobject x_obj;	void *lpc_importOutlet;		// Import Output Outlet	void *lpc_doneOutlet;		// done Outlet	Atom lpc_outList[105];		// used for sending lists out	Symbol *lpc_fn;			// file name	char lpc_read;				// flag for read method (dialog or defined)	short lpc_vol;				// file path} t_lpc;// Prototypes for methods: need a method for each incoming message type:void *lpc_new(void);										// void lpc_assist(t_lpc *x, void *b, long m, long a, char *s);			// void lpc_read(t_lpc *x, t_symbol *s);						// Import a saved analysisvoid lpc_fromfile(t_lpc *x, char *name, short vol, OSType type);	//void lpc_finished_reading(t_lpc *x);							//void lpc_doread(t_lpc *x);									//void lpc_free(t_lpc *x);									///************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{    setup((t_messlist **)&lpc_class, (method)lpc_new, (method)lpc_free, (short)sizeof(t_lpc), 0L, 0);	addmess((method)lpc_assist,"assist",A_CANT,0);	addmess((method)lpc_read, "read", A_DEFSYM, 0);	addmess((method)lpc_read, "import", A_DEFSYM, 0);	addmess((method)inspector_open, "info", A_CANT, 0);			// bind method for opening the license window		post("tap.lpc~ v1.1 - Copyright © 2001 by Timothy A. Place");	// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *lpc_new(void){	t_lpc *x = (t_lpc *)newobject(lpc_class);				// Pointer	x->lpc_doneOutlet = bangout(x);	x->lpc_importOutlet = outlet_new(&x->x_obj, "list");		// Create outlet for imported data	return (x);									// Return the object's pointer}/************************************************************************************/// Methods bound to input/inlets// Assistance Messagesvoid lpc_assist(t_lpc *x, void *b, long msg, long arg, char *dst){	if(msg==1) 	// Inlets		strcpy(dst, "read, import, etc.");	else if(msg==2){ // Outlets		switch(arg){			case 0: strcpy(dst, "(lists) connect to coll"); break;			case 1: strcpy(dst, "(bang) when done importing"); break;		}	}}// Memory Deallocationvoid lpc_free(t_lpc *x){	notify_free((t_object *)x);}// Read method to defer the actual file handling so it doesn't happen at interupt levelvoid lpc_read(t_lpc *x, t_symbol *s){	if (s->s_name[0]){		x->lpc_read = FILE_NAMED;	// set flag		x->lpc_fn = s;				// file name = symbol typed in	}	else		x->lpc_read = FILE_DIALOG;	// set flag	defer(x, (method)lpc_doread, 0, 0, 0);}// Actually figure out how the user is choosing to define the file and set itvoid lpc_doread(t_lpc *x){	short vol,numtypes = 2;	long i;	long type;	char name[256];	name[0] = 0;		if (x->lpc_read==FILE_DIALOG) {			if (!open_dialog(name, &vol, &type, NULL, -1)) {			lpc_fromfile(x,name,vol,type);			x->lpc_fn = gensym(name);			x->lpc_vol = vol;			lpc_finished_reading(x);		}	}	else if(x->lpc_read == FILE_NAMED){		strcpy(name, x->lpc_fn->s_name);		// 'de-Symbol' the file name		if (!locatefile_extended (name, &x->lpc_vol, &type, NULL, -1)){			lpc_fromfile(x, name, x->lpc_vol, type);			lpc_finished_reading(x);		}		else{			error("tap.lpc~: can't read file %s", x->lpc_fn->s_name);			x->lpc_fn = gensym(" ");		}	}}// Actually read the filevoid lpc_fromfile(t_lpc *x, char *name, short vol, OSType type){	short err;	FILE_REF fd;	long i = 1;	long listLength = 0, listCounter = 0;	short dataPerFrame;	long numberOfFrames;	float frameRate;	float length;	float test;		// temp. storage	long test2;	// temp. storage	char test3[4];	// temp. storage		err = path_openfile(name, vol, &fd, READ_PERM);	if (err){		error("tap.lpc~: error %d opening file %s", err, name);		return;	}	   	outlet_anything(x->lpc_importOutlet, gensym("clear"), 0, NIL); 	//clear the coll	{		long bytecount = 4;		for (i=0; i<=8; i++){			if(listLength == 0)	// If at the first element, insert an index number first			{				SETLONG(x->lpc_outList+listLength,listCounter);				listLength++;			}						if(listCounter == 0)	// HEADER			{				if(listLength <= 4)				{					FSRead(fd, &bytecount, &test2);					SETLONG(x->lpc_outList+listLength ,test2);	// put the number at the current index					if(listLength == 4)						dataPerFrame = test2;					listLength++;				}				else if(listLength <= 7)				{					FSRead(fd, &bytecount, &test);					SETFLOAT(x->lpc_outList+listLength, test);	// put the number at the current index					if (listLength == 5)						length = test;					else if (listLength == 7){						frameRate = test;						numberOfFrames = (long)(frameRate * length);						post("tap.lpc~ importing %i frames of lp analysis", numberOfFrames);					}						listLength++;									}				else if(listLength == 8)				{					bytecount = 2;					for (i=0; i<4; i++){						FSRead(fd, &bytecount, &test3);						SETSYM(x->lpc_outList+listLength, " "/*test3*/);	// put the string at the current index						listLength++;						}						bytecount = 4;				}				else				{					outlet_list(x->lpc_importOutlet, 0L, listLength, x->lpc_outList); //output data					listLength = 0;	// reset length counter					listCounter++;	// advance to the next index										SETLONG(x->lpc_outList+listLength,listCounter);					listLength++;					SETFLOAT(x->lpc_outList+listLength,test);	// put the number at the current index					listLength++;										}				}		}			for (i=0;i < (numberOfFrames * dataPerFrame); i++){	// DATA			FSRead(fd, &bytecount, &test);			if(listLength <= dataPerFrame)			{				SETFLOAT(x->lpc_outList+listLength,test);	// put the number at the current index				listLength++;									}			else			{				outlet_list(x->lpc_importOutlet, 0L, listLength, x->lpc_outList); //output data				listLength = 0;	// reset length counter				listCounter++;	// advance to the next index				SETLONG(x->lpc_outList+listLength,listCounter);				listLength++;				SETFLOAT(x->lpc_outList+listLength,test);	// put the number at the current index				listLength++;									}								}	}			FSClose(fd);	// FSClose refers to the files reference number}  // Let the user know the file reading is donevoid lpc_finished_reading(t_lpc *x){	post("tap.lpc~ finished reading");	outlet_bang(x->lpc_doneOutlet);}