// MSP External: tap.typecheck~.c// check datatype and send out the appropriate outlet// T.Place - 01/08/2002#include "ext.h"				// Required for all Max External Objects#include "z_dsp.h"			// Required for all MSP External Objects	#include "ext_strings.h"	void *tc_class;			// Required. Global pointing to this classtypedef struct _tc		// Data Structure for this object{	t_pxobject x_obj;		void *tc_bangOut;	// bang outlet	void *tc_intOut;		// int outlet	void *tc_floatOut;	// Floating-point outlet	void *tc_symbolOut;	// symbol outlet	void *tc_listOut;		// list outlet} t_tc;// Prototypes for methods: need a method for each incoming message type:t_int *tc_perform(t_int *w);							// An MSP Perform (signal) Methodvoid tc_dsp(t_tc *x, t_signal **sp, short *count);				// DSP Methodvoid tc_assist(t_tc *x, void *b, long m, long a, char *s);		// Assistance Methodvoid *tc_new(void);	// New Object Creation Methodvoid tc_bang(t_tc *x);								// Bang methodvoid tc_int(t_tc *x, long value);							// Int methodvoid tc_float(t_tc *x, double value);						// Float methodvoid tc_symbol(t_tc *x, Symbol *msg, short argc, Atom *argv);	// Symbol methodvoid tc_list(t_tc *x, Symbol *msg, short argc, Atom *argv);		// List methodvoid tc_free(t_tc *x);/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&tc_class, (method)tc_new, (method)tc_free, (short)sizeof(t_tc), 0L, 0L, 0);	    						addmess((method)tc_dsp, "dsp", A_CANT, 0);						// Bind method "tc_dsp" to the DSP call from MSP	addmess((method)tc_assist,"assist", A_CANT, 0);						// Bind method "tc_assist" to assistance calls	addmess((method)inspector_open, "info", A_CANT, 0);					// bind method for opening the license window	addbang((method)tc_bang);											addint((method)tc_int);											addfloat((method)tc_float);											addmess((method)tc_list, "list", A_GIMME, 0);											addmess((method)tc_symbol, "anything", A_GIMME, 0);											dsp_initclass();												// Setup object's class to work with MSP	post("tap.typecheck~ v1.0 - Copyright © 2002 by Timothy A. Place");		// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *tc_new(void){	t_tc *x = (t_tc *)newobject(tc_class);	dsp_setup((t_pxobject *)x,1);    	x->tc_symbolOut = outlet_new(x, 0);	    	x->tc_listOut = listout(x);    	x->tc_floatOut = floatout(x);	x->tc_intOut = intout(x);	x->tc_bangOut = bangout(x);	outlet_new((t_object *)x, "signal");	return (x);}/************************************************************************************/// Methods bound to input/inlets// Method for Assistance Messagesvoid tc_assist(t_tc *x, void *b, long msg, long arg, char *dst){	if(msg==1) 		// Inlets		strcpy(dst, "Any Input");	else if(msg==2){ 	// Outlets		switch(arg){			case 0: strcpy(dst, "(signal) Output"); break;			case 1: strcpy(dst, "(bang) Output"); break;			case 2: strcpy(dst, "(int) Output"); break;			case 3: strcpy(dst, "(float) Output"); break;			case 4: strcpy(dst, "(list) Output"); break;			case 5: strcpy(dst, "(symbol) Output"); break;		}	}}void tc_bang(t_tc *x){	outlet_bang(x->tc_bangOut);			// output the result		}void tc_int(t_tc *x, long value){	outlet_int(x->tc_intOut, value);		// output the result		}void tc_float(t_tc *x, double value){	outlet_float(x->tc_floatOut, value);		// output the result		}void tc_list(t_tc *x, Symbol *msg, short argc, Atom *argv){	outlet_list(x->tc_listOut, 0L, argc, argv);		// output the result		}void tc_symbol(t_tc *x, Symbol *msg, short argc, Atom *argv){	if(argc == 0)		outlet_anything(x->tc_symbolOut, msg, argc, argv);		// output the result	else		outlet_anything(x->tc_listOut, msg, argc, argv);		// output the result	}// Memory Deallocationvoid tc_free(t_tc *x){	notify_free((t_object *)x);	dsp_free((t_pxobject *)x);}// Perform (signal) Method - delay is a constant (not a signal)t_int *tc_perform(t_int *w){	t_float *in, value, *out;	int n;	t_tc *x = (t_tc *)(w[1]);			in = (t_float *)(w[2]);	out = (t_float *)(w[3]);	n = (int)(w[4]);				while (--n) 	{		value = *++in;			// Input		*++out = value;			// output the result						}	return (w+5);}// DSP Methodvoid tc_dsp(t_tc *x, t_signal **sp, short *count){	if (count[0])   		dsp_add(tc_perform, 4, x, sp[0]->s_vec-1, sp[1]->s_vec-1, sp[0]->s_n + 1);   	else   		;}