// MSP External: tap.noise~.c// noise generator// T.Place - 05.13.2001//		v0.6 (08/27/01) - update for Max/MSP 4//		v0.7 (12/14/01) - minor revisions#include "ext.h"			// Required for all Max External Objects#include "z_dsp.h"		// Required for all MSP External Objects#include "ext_strings.h"		// Used for the assistance stringsvoid *noise_class;		// Required. Global pointing to this classstatic long randx = 1;	// Seedtypedef struct _noise	// Data Structure for this object{	t_pxobject x_obj;	int noise_mode;	float noise_b0, noise_b1, noise_b2, noise_b3, noise_b4, noise_b5, noise_b6; // Coefficients for the "pinking" filter} t_noise;// Prototypes for methods: need a method for each incoming message typevoid *noise_new(long mode);							// New Object Creation Methodt_int *noise_perform(t_int *w);						// An MSP Perform (signal) Methodvoid noise_dsp(t_noise *x, t_signal **sp, short *count);		// DSP Methodvoid noise_assist(t_noise *x, void *b, long m, long a, char *s);	// Assistance Methodvoid noise_int(t_noise *x, long mode);					// Int Methodfloat fclip(float a, float b, float c);						//long clip(long a, long b, long c);							//void noise_free(t_noise *x);/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&noise_class, (method)noise_new, (method)noise_free, (short)sizeof(t_noise), 0L, A_DEFLONG, 0);	addmess((method)noise_dsp, "dsp", A_CANT, 0);					// Bind method "noise_dsp" to the DSP call from MSP	addmess((method)noise_assist, "assist", A_CANT, 0);				// Bind method "noise_assist" to assistance calls	addint((method)noise_int);									// Bind int method to mode	addmess((method)inspector_open, "info", A_CANT, 0);				// bind method for opening the license window		dsp_initclass();												// Setup object's class to work with MSP	post("tap.noise~ v0.7 - Copyright © 2001 by Timothy A. Place");		// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *noise_new(long mode){	t_noise *x = (t_noise *)newobject(noise_class);		dsp_setup((t_pxobject *)x,1);				// Create Object and 1 Inlet (last argument)	outlet_new((t_pxobject *)x, "signal");		// Create a signal Outlet  	mode = clip(mode, 0, 3); 	x->noise_mode = mode;					// Default Mode	return (x);							// Return the pointer}/************************************************************************************/// Methods bound to input/inlets// Method for Assistance Messagesvoid noise_assist(t_noise *x, void *b, long msg, long arg, char *dst){	if(msg==1)	// Inlet		strcpy(dst, "(int) Mode");	else if(msg==2) // Outlet		strcpy(dst, "(signal) Noise output");}// float Methodvoid noise_int(t_noise *x, long mode){	mode = clip(mode, 0, 3);	x->noise_mode = mode;}// Memory Deallocationvoid noise_free(t_noise *x){	notify_free((t_object *)x);	dsp_free((t_pxobject *)x);}// Perform (signal) Methodt_int *noise_perform(t_int *w){	t_float *out = (t_float *)(w[1]);	// Output   	t_noise *x = (t_noise *)(w[2]);		// Pointer	int n = (int)(w[3]);				// Vector Size			unsigned long i;					// used by random gen.	float white;					// stores white noise	float pink;						// stores pink noise	float brown;					// stores brown noise	float blue;						// stored blue noise				if (x->x_obj.z_disabled) return (w+4);	if (x->noise_mode == 0)		// WHITE	{		while (--n) 		{			i = ((randx = randx*1103515245 + 12345)>>16) & 077777;	// Random Gen.			*++out = (float)i/16384. - 1.;							// Output White Noise		}		}	else if (x->noise_mode == 1)	// PINK	{		while (--n)		{			i = ((randx = randx*1103515245 + 12345)>>16) & 077777;	// Random Gen.			white = (float)i/16384. - 1.;							// White Noise						x->noise_b0 = 0.99886 * x->noise_b0 + white * 0.0555179;	// Pinking filter...			x->noise_b1 = 0.99332 * x->noise_b1 + white * 0.0750759; 			x->noise_b2 = 0.96900 * x->noise_b2 + white * 0.1538520; 			x->noise_b3 = 0.86650 * x->noise_b3 + white * 0.3104856; 			x->noise_b4 = 0.55000 * x->noise_b4 + white * 0.5329522; 			x->noise_b5 = -0.7616 * x->noise_b5 - white * 0.0168980; 			pink = x->noise_b0 + x->noise_b1 + x->noise_b2 + x->noise_b3 + x->noise_b4 + x->noise_b5 + x->noise_b6 + white * 0.5362; 			x->noise_b6 = white * 0.115926; 			*++out = pink * 0.1;									// Output					}	}	else if (x->noise_mode == 2)	// BROWN	{		while (--n)		{			i = ((randx = randx*1103515245 + 12345)>>16) & 077777;	// Random Gen.			white = (float)i/16384. - 1.;							// White Noise					white = white * 0.1;									// Scale the white noise						brown = x->noise_b1 + white;							// 6dB per octave lowpass			brown = fclip(brown, -1., 1.);							// Clip			*++out = brown * 0.25;								// Output			x->noise_b1 =brown;									// Store Feedback Sample		}	}	else if (x->noise_mode == 3)	// BLUE	{		while (--n)		{			i = ((randx = randx*1103515245 + 12345)>>16) & 077777;	// Random Gen.			white = (float)i/16384. - 1.;							// White Noise														blue = white - x->noise_b1;							// 6dB per octave highpass (real blue noise = 3dB/oct)			blue = fclip(blue, -1., 1.);								// Clip 			*++out = blue;										// Output			x->noise_b1 = blue;									// Store Feedback Sample		}			}		return (w + 4);				// Return a pointer to the NEXT object in the DSP call chain}// DSP Methodvoid noise_dsp(t_noise *x, t_signal **sp, short *count){	x->noise_b0 = x->noise_b1 = x->noise_b2 = x->noise_b3 = x->noise_b4 = x->noise_b5 = x->noise_b6 = 0; 	dsp_add(noise_perform, 3, sp[1]->s_vec-1, x, sp[0]->s_n+1);	}/************************************************************************************/// Other Functions used by object// Utility function to keep values in rangelong clip(long a, long b, long c){	return a < b? b: (a > c? c : a);}// Utility function to keep values in rangefloat fclip(float a, float b, float c){	return a < b? b: (a > c? c : a);}