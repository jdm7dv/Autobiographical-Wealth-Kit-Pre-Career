// MSP External: tap.auto_thru~.c// A thru object that switches to the 2nd inlet if it is connected// T.Place - 04/06/2001//		v1.1 (08/27/2001) - update for Max/MSP 4//		v1.2 (11/30/2001) - minor improvements (remove resources, etc.)#include "ext.h"				// Required for all Max External Objects#include "z_dsp.h"			// Required for all MSP External Objects#include "ext_strings.h"		// Used for the assistance stringsvoid *thru_class;			// Required. Global pointing to this classtypedef struct _thru		// Data Structure for this object{	t_pxobject x_obj;} t_thru;// Prototypes for methods: need a method for each incoming message typevoid *thru_new(void);								// New Object Creation Methodt_int *thru_perform(t_int *w);							// An MSP Perform (signal) Methodt_int *thru_perform2(t_int *w);						// A second Perform Methodvoid thru_dsp(t_thru *x, t_signal **sp, short *count);		// DSP Methodvoid thru_assist(t_thru *x, void *b, long m, long a, char *s);	// Assistance Methodvoid thru_free(t_thru *x);/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&thru_class, (method)thru_new, (method)thru_free, (short)sizeof(t_thru), 0L, 0);	addmess((method)thru_dsp, "dsp", A_CANT, 0);					// Bind method "thru_dsp" to the DSP call from MSP	addmess((method)thru_assist, "assist", A_CANT, 0);				// Bind method "thru_assist" to assistance calls	addmess((method)inspector_open, "info", A_CANT, 0);				// bind method for opening the license window		dsp_initclass();												// Setup object's class to work with MSP	post("tap.auto_thru~ v1.2 - Copyright © 2001 by Timothy A. Place");	// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *thru_new(void){	t_thru *x = (t_thru *)newobject(thru_class);		dsp_setup((t_pxobject *)x,2);				// Create Object and 2 Inlet (last argument)	outlet_new((t_pxobject *)x, "signal");		// Create a signal Outlet	return (x);							// Return the pointer}/************************************************************************************/// Methods bound to input/inlets// Method for Assistance Messagesvoid thru_assist(t_thru *x, void *b, long msg, long arg, char *dst){	if(msg==1){ 	// Inlets		switch(arg){			case 0: strcpy(dst, "(signal) Will go thru if inlet 2 is not connected"); break;			case 1: strcpy(dst, "(signal) will cut-off inlet 1 if connected"); break;		}	}	else if(msg==2) // Outlets		strcpy(dst, "(signal) signal 2 if connected, else signal 1");}// Memory Deallocationvoid thru_free(t_thru *x){	notify_free((t_object *)x);	dsp_free((t_pxobject *)x);}// Perform (signal) Methodt_int *thru_perform(t_int *w){	t_float *in = (t_float *)(w[1]);   		// Input	t_float *out = (t_float *)(w[2]);		// Output   	t_thru *x = (t_thru *)(w[3]);			// Pointer	int n = (int)(w[4]);					// Vector Size				while (--n) 		*++out = *++in;							                       	return (w + 5);						// Return a pointer to the NEXT object in the DSP call chain			                       }// Perform (signal) Method2t_int *thru_perform2(t_int *w){	t_float *in = (t_float *)(w[1]);   		// Input	t_float *out = (t_float *)(w[2]);		// Output   	t_thru *x = (t_thru *)(w[3]);			// Pointer	int n = (int)(w[4]);					// Vector Size				while (--n) 		*++out = *++in;					                       	return (w + 5);						// Return a pointer to the NEXT object in the DSP call chain			                       }// DSP Methodvoid thru_dsp(t_thru *x, t_signal **sp, short *count){	if (count[1])		dsp_add(thru_perform2, 4, sp[1]->s_vec-1, sp[2]->s_vec-1, x, sp[0]->s_n+1);	// Add Perform Method to the DSP Call Chain		 	else		dsp_add(thru_perform, 4, sp[0]->s_vec-1, sp[2]->s_vec-1, x, sp[0]->s_n+1);		// Add Perform Method to the DSP Call Chain}