//  tap.allpole~//  allpole filter for Max/MSP//  by Timothy A. Place © 2001 - 08/29/01//		v1.1 (12/14/01) - minor revisions#include "ext.h"#include "z_dsp.h"#include "ext_strings.h"				// Used for the assistance strings#define MAX_POLES 100void *allpole_class;					// Required. Global pointing to this classtypedef struct _allpole				// Data Structure for this object{	t_pxobject x_obj;	float allpole_coefs[100];			// filter coefficients	float allpole_fb[100];			// feedback samples	float allpole_clip;				// auto clipping toggle	long allpole_resynthPoles;	int allpole_sr;	float allpole_gain;				// gain coef	short allpole_connect;			// gain connection	double line_result[100];	double line_destination[100];	double line_step[100];	long line_samplenum[100];	long line_samplesDone[100]; 	float line_slewTime;	} t_allpole;// Prototypes for methods: need a method for each incoming message type:void *allpole_new(long numberOfPoles, float gain);					// void allpole_assist(t_allpole *x, void *b, long m, long a, char *s);		// void allpole_list(t_allpole *x, Symbol *msg, short argc, Atom *argv);		// List of Coefficientsvoid allpole_clear(t_allpole *x);									// re-init the filtervoid allpole_dsp(t_allpole *x, t_signal **sp, short *count);				// DSP Methodt_int *allpole_perform(t_int *w);								// Perform (signal) Methodvoid allpole_free(t_allpole *x);float fclip(float a, float b, float c);long clip(long a, long b, long c);void allpole_clip(t_allpole *x, float value);void allpole_interpolation(t_allpole *x, float value);float perform_interpolation(t_allpole *x, short inletNumber);void interp_calc(t_allpole *x, short i);void allpole_gain(t_allpole *x, float value);/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&allpole_class, (method)allpole_new, (method)allpole_free, (short)sizeof(t_allpole), 0L, A_DEFLONG, A_DEFLONG, 0);	addfloat((method)allpole_gain);	addmess((method)allpole_dsp, "dsp", A_CANT, 0);					// Bind method "allpole_dsp" to the DSP call from MSP    	    					addmess((method)allpole_assist,"assist",A_CANT,0);	addmess((method)allpole_clip, "clip", A_FLOAT, 0);	addmess((method)allpole_list, "list", A_GIMME, 0);	addmess((method)allpole_clear, "clear", 0);	addmess((method)allpole_interpolation, "interpolation", A_FLOAT, 0);	addmess((method)inspector_open, "info", A_CANT, 0);				// bind method for opening the license window		dsp_initclass();												// Setup object's class to work with MSP	post("tap.allpole~ v1.1 - Copyright © 2001 by Timothy A. Place");		// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *allpole_new(long numberOfPoles, float gain){	short i;	t_allpole *x = (t_allpole *)newobject(allpole_class);		// Pointer	dsp_setup((t_pxobject *)x, 3);						// Create object with 2 inlets	outlet_new((t_pxobject *)x, "signal");				// Create a signal Outlet		if (numberOfPoles == 0)		numberOfPoles = 2;	for (i=0; i<MAX_POLES; i++){		x->allpole_coefs[i] = 0.;						// filter coefficients		x->allpole_fb[i] = 0.;							// feedback samples		x->line_result[i] = 0.;		x->line_destination[i] = 0.;		x->line_step[i] = 0.;		x->line_samplenum[i] = 0.;		x->line_samplesDone[i] = 0.; 	}	x->allpole_gain = gain;	x->line_slewTime = 0;	x->allpole_clip = 100.0;	post("tap.allpole~ initialized with %i pole(s)", x->allpole_resynthPoles = clip(numberOfPoles, 1, MAX_POLES)); 		return (x);									// Return the object's pointer}/************************************************************************************/// Methods bound to input/inlets// Assistance Messagesvoid allpole_assist(t_allpole *x, void *b, long msg, long arg, char *dst){	if(msg==1){ 	// Inlets		switch(arg){			case 0: strcpy(dst, "(signal) to be filtered"); break;			case 1: strcpy(dst, "(float) gain coefficient"); break;			case 2: strcpy(dst, "(list) feedback coefficients"); break;		}	}	else if(msg==2) // Outlets		strcpy(dst, "(signal) Filtered output");}// Change the gain coefvoid allpole_gain(t_allpole *x, float value){	switch (x->x_obj.z_in) {		case 1:			x->allpole_gain = value;				break;		case 2:			x->allpole_coefs[0] = value;			interp_calc(x, 0);			break;	}}// List of Coefficients Methodvoid allpole_list(t_allpole *x, Symbol *msg, short argc, Atom *argv){	int	i;		for(i=0; i<argc; i++, argv++){		x->allpole_coefs[i]=argv->a_w.w_float;	// load the list into the coefficient array		interp_calc(x, i);	}}// Calculate the interpolation trajectoriesvoid interp_calc(t_allpole *x, short i){	float f, ff, diff, step;	int slew;	if ( x->line_slewTime != 0 )							// If interpolation is desired...	{			slew = (int)(x->line_slewTime * 0.001 * x->allpole_sr);	//  slewtime_in_samples = ms -> sec * sr							ff = x->line_result[i]; 							// most recent output value		diff = x->allpole_coefs[i] - ff;						// difference between it, and new value		step = diff / slew;								// increment per sample to interpolate linearly		x->line_destination[i] = x->allpole_coefs[i];			// store final destination		x->line_step[i] = step;							// store step size of the interpolation		x->line_samplenum[i] = slew;						// needed for triggering the interpolation		x->line_samplesDone[i] = 0;						// Reset the position in the interpolation process	}}// auto-clipping togglevoid allpole_clip(t_allpole *x, float value){	x->allpole_clip = value;}// Set interpolation timevoid allpole_interpolation(t_allpole *x, float value){	x->line_slewTime = value;}// Clear: re-init the filtervoid allpole_clear(t_allpole *x){	int	i;		for(i=0; i < MAX_POLES; i++)	{		x->allpole_fb[i] = 0.0;	}}// Memory Deallocationvoid allpole_free(t_allpole *x){	notify_free((t_object *)x);	dsp_free((t_pxobject *)x);}// Perform Methodt_int *allpole_perform(t_int *w){	t_float *in = (t_float *)(w[1]);   	// Input	t_float *in2 = (t_float *)(w[2]);	t_float *out = (t_float *)(w[4]);	// Output   	t_allpole *x = (t_allpole *)(w[5]);	// Pointer	int n = (int)(w[6]);				// Vector Size		int		i;								double 	value, fb_sum, input;							float		limit = x->allpole_clip, gain;				if (x->x_obj.z_disabled) goto byebye; 	gain = x->allpole_connect ? *(t_float *)(w[2]) : x->allpole_gain;	while (--n) 	{		// INTERPOLATION OF COEFFICIENTS		for(i=0; i < x->allpole_resynthPoles; i++){			if(x->line_slewTime != 0)				x->allpole_coefs[i] = perform_interpolation(x, i);		}		// SIGNAL FILTERING		value = input = *++in;									// Input		fb_sum = 0;											// init the sum of the feedback		for(i = 0; i < x->allpole_resynthPoles; i++)			fb_sum = fb_sum - (x->allpole_coefs[i] * x->allpole_fb[i]);	// sum the weighted feedback		if (x->allpole_clip != 0) value = fclip((value * x->allpole_gain + fb_sum), -limit, limit);	// find the current output (clipped)		else value = value * x->allpole_gain + fb_sum;								// or find the current output		*++out = value;											// Output				for(i = ( x->allpole_resynthPoles); i > 0; i--)					// Shift the feedback samples			x->allpole_fb[i] = x->allpole_fb[i-1];		x->allpole_fb[0] = value;									// store the feedback								}	byebye:    return (w + 7);		// Return a pointer to the NEXT object in the DSP call chain}// Interpolator...float perform_interpolation(t_allpole *x, short inletNumber){	double xx;	if (x->line_samplesDone[inletNumber] != x->line_samplenum[inletNumber])	{		xx = x->line_result[inletNumber] + x->line_step[inletNumber];		x->line_samplesDone[inletNumber]= x->line_samplesDone[inletNumber] + 1;		x->line_result[inletNumber] = xx;				// store the result									return(xx);	}	return(x->line_result[inletNumber]);}// DSP Methodvoid allpole_dsp(t_allpole *x, t_signal **sp, short *count){	x->allpole_sr = sp[0]->s_sr;			// find local sr	allpole_clear(x);					// re-init the filter	x->allpole_connect = count[1];			// store the state of the second inlet	dsp_add(allpole_perform, 6, sp[0]->s_vec-1, sp[1]->s_vec-1, sp[2]->s_vec-1,		sp[3]->s_vec-1, x, sp[0]->s_n+1);	// Add Perform Method to the DSP Call Chain}/************************************************************************************/// Other Functions used by object// Utility function to keep coefficients in checkfloat fclip(float a, float b, float c){	return a < b? b: (a > c? c : a);}// Utility function to keep coefficients in checklong clip(long a, long b, long c){	return a < b? b: (a > c? c : a);}