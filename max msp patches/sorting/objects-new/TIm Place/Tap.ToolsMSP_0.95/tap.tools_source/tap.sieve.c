// Max External: sieve.c// T.Place - 7/16/2000// A Max object resembling select, except that it outputs the matched item rather than a bang.//		v1.01 (08/17/2001) - update for Max 4//		v1.02 (11/30/01) - minor revisions#include "ext.h"				// Required for all Max external objects#include "z_dsp.h"			// Required for all MSP External Objects#include "ext_strings.h"		// Used for the assistance stringsvoid *this_class;			// Required. Global pointing to this class typedef struct sieve			// Data structure for this object {	Object p_ob;			// Must always be the first field; used by Max 	long p_value;			// Value from which to determine next prime number	long p_primen;			// Prime number to be sent out	void *p_out;			// Pointer to outlet. need one for each outlet 	Atom match_list[100];} Sieve;		// Prototypes for methods: need a method for each incoming messagevoid *sieve_new(t_symbol *str, short argc, t_atom *argv);			// object creation method  void *sieve_bang(Sieve *sieve);									// method for "bang" message void *sieve_int(Sieve *sieve, long value);							// method for int inputvoid *sieve_right(Sieve *sieve, long value);						// method for right inlet int inputvoid sieve_assist(Sieve *sieve, void *b, long m, long a, char *s); 		// assistance messagesvoid sieve_free(Sieve *sieve);									// free method/*********************************************************///Main() Functionvoid main(void)			//main receives a copy of the Max function macros table {		// set up our class: create a class definition 	setup((t_messlist **)&this_class, (method)sieve_new, (method)sieve_free, (short)sizeof(Sieve), 0L, A_GIMME, 0);	addint((method)sieve_int);							// bind method "sieve_int" to the int input (L inlet)	addinx((method)sieve_right, 1);							// bind method "sieve_right" to int received from R inlet	addmess((method)sieve_assist, "assist", A_CANT, 0);		// Bind method "sieve_assist" to assistance calls	addmess((method)inspector_open, "info", A_CANT, 0);		// bind method for opening the license window		alias("sieve");										// ...for backwards compatibility	post("tap.sieve v1.02 - Copyright © 2000-2001 by Timothy A. Place");		post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/*********************************************************///Object Creation Functionvoid *sieve_new(t_symbol *str, short argc, t_atom *argv){	Sieve *sieve;	sieve = (Sieve *)newobject(this_class);			// create the new instance and return a pointer to it 	sieve->p_value = atom_getintarg(0,argc,argv);		// Init the value to match	sieve->p_out = intout(sieve);					// Create the outlet	intin(sieve, argc);							// Create right inlet		return(sieve);								// must return a pointer to the new instance }/*********************************************************///Bound to inlet Functions// Method for Assistance Messagesvoid sieve_assist(Sieve *sieve, void *b, long msg, long arg, char *dst){	if(msg==1){ 	// Inlets		switch(arg){			case 0: strcpy(dst, "Input to be tested"); break;			case 1: strcpy(dst, "Set a new item to match"); break;		}	}	else if(msg==2) // Outlets		strcpy(dst, "The matched input");}// INT in left inletvoid *sieve_int(Sieve *sieve, long value){	int	i;		i = sieve->p_value;								// load the data into a local variable		if( value == i)									// if it matches...		outlet_int(sieve->p_out, sieve->p_value);			// spit it out}// INT in right inletvoid *sieve_right(Sieve *sieve, long value){	sieve->p_value = value;}// free methodvoid sieve_free(Sieve *sieve){	notify_free((t_object *)sieve);}