// Max External: prime.c// T.Place - 11/04/1999// A simple Max object to step through prime numbers.//		v1.1 (11/06/1999) - add assistance strings//		v1.2 (06/21/2000) - accepts floats, which are rounded to ints; Minor Optimizations//		v1.21 (04/28/2001) - fix Resedit IDs, recompile for tap.tools//		v1.22 (08/17/2001) - update for Max 4//		v1.3 (09/26/2001) - removed MAXL resource//		v1.4 (11/30/2001) - minor improvements#include "ext.h"			// Required for all Max external objects#include <math.h>		// Needed for sqrt() function#include <MacTypes.h>	// Needed to define true and false#include "ext_strings.h"	// Used for assistance stringsvoid *this_class;			// Required. Global pointing to this class typedef struct prime		// Data structure for this object {	Object	p_ob;		// Must always be the first field; used by Max 	long 		p_value;		// Value from which to determine next prime number	void 		*p_out;		// Pointer to outlet. need one for each outlet } Prime;		// Prototypes for methods: need a method for each incoming messagevoid	*prime_new(long value);								// object creation method  void	*prime_bang(Prime *prime);							// method for "bang" message void	*prime_int(Prime *prime, long value);					// method for int inputvoid	*prime_right(Prime *prime, long value);					// method for right inlet int inputint	primeFunc (int testNum);								// prime number functionvoid	prime_assist(Prime *prime, void *b, long m, long a, char *s); 	// assistance messagesvoid	prime_free(Prime *prime);							// free method/*********************************************************///Main() Functionvoid main(void)			//main receives a copy of the Max function macros table {		// set up our class: create a class definition 	setup((t_messlist **)&this_class, (method)prime_new, (method)prime_free, (short)sizeof(Prime), 0L, A_DEFLONG, 0);	addbang((method)prime_bang); 						// bind method "bang_bang" to the "bang" message	addint((method)prime_int);							// bind method "int_int" to the int input (L inlet)	addinx((method)prime_right, 1);						// bind method "int_right" to int received from R inlet	addmess((method)prime_assist, "assist", A_CANT, 0);		// bind method "prime_assist" to assistance calls	addmess((method)inspector_open, "info", A_CANT, 0);		// bind method for opening the license window		alias("prime");										// ...for backwards compatibility	post("tap.prime v1.4 - Copyright © 1999-2001 by Timothy A. Place");	// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/*********************************************************///Object Creation Functionvoid *prime_new(long value){	Prime *prime;	prime = (Prime *)newobject(this_class);	// create the new instance and return a pointer to it 	prime->p_value = value;				//Init the prime value	prime->p_out = intout(prime);			//Create the outlet	intin(prime,1);						//Create right inlet	return(prime);						// must return a pointer to the new instance }/*********************************************************///Bound to inlet Functions// Method for Assistance Messagesvoid prime_assist(Prime *prime, void *b, long msg, long arg, char *dst){	if(msg==1){ 	// Inlets		switch(arg){			case 0: strcpy(dst, "(bang/int) Step to the next prime number"); break;			case 1: strcpy(dst, "(int) Set the next prime to step to"); break;		}	}	else if(msg==2) // Outlets		strcpy(dst, "(int) Prime number");}// BANG in left inletvoid *prime_bang(Prime *prime){	prime->p_value = primeFunc(prime->p_value);	// run the primeFunc function on the stored value and store the result	outlet_int(prime->p_out, prime->p_value);	// output the result	}// INT in left inletvoid *prime_int(Prime *prime, long value){	prime->p_value = primeFunc(value);			// run the primeFunc function on the input value and store the result	outlet_int(prime->p_out, prime->p_value);	// output the result}// INT in right inletvoid *prime_right(Prime *prime, long value){	prime->p_value = value;					//Set the value}// free methodvoid prime_free(Prime *prime){	notify_free((t_object *)prime);}/*********************************************************///Additional Functions// Prime Number Functionint primeFunc (int testNum){	int      candidate, last, i, isPrime;   	if ( testNum < 2 )  		candidate = 2;	else if ( testNum == 2 )		candidate = 3;	else{		candidate = testNum;		if (candidate % 2 == 0)    					// Test only odd numbers			candidate--;		do{			isPrime = true;							// Assume glorious success			candidate += 2;               					// Bump to the next number to test			last = sqrt( candidate );      				// We'll check to see if candidate has any factors, from 2 to last			for ( i = 3; (i <= last) && isPrime; i += 2 ){		// Loop through odd numbers only				if ( (candidate % i) == 0 )				isPrime = false;			}		} 		while ( ! isPrime );	}	return candidate;}