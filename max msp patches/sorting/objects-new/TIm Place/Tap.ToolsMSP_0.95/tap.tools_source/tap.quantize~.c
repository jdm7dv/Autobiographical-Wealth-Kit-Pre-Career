// MSP External: quantize~.c// An MSP object to round the sample values of audio streams// T.Place - 99.12.04 (completed 99.12.06)// 		v1.1 (12/21/99) - added ability to take an argument to specify the multiplication.// 		v1.2 (01/15/00) - minor optimizations// 		v1.21(04/28/01) - ResEdit ID fix, recompile for tap.tools//		v1.3 (08/27/01) - update for Max/MSP 4//		v1.4 (12/14/01) - minor revisions#include "ext.h"				// Required for all Max External Objects#include "z_dsp.h"			// Required for all MSP External Objects#include "ext_strings.h"		// Used for the assistance stringsvoid *quantize_class;		// Required. Global pointing to this classtypedef struct _quantize		// Data Structure for this object{	t_pxobject x_obj;		// Header;  Must always be the first field; used by MSP	long b_value;		    	// Value from the typed in argument} t_quantize;// Prototypes for methods: need a method for each incoming message typevoid *quantize_new(float value);								// New Object Creation Methodt_int *quantize_perform(t_int *w);								// An MSP Perform (signal) Methodvoid quantize_dsp(t_quantize *x, t_signal **sp, short *count);			// DSP Methodvoid quantize_assist(t_quantize *x, void *b, long m, long a, char *s);		// Assistance Methoddouble roundFunc (double incoming, double maxarg);					// Decimal Rounder Functionvoid quantize_free(t_quantize *x);/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&quantize_class, (method)quantize_new, (method)quantize_free, (short)sizeof(t_quantize), 0L, A_DEFFLOAT, 0); 	addmess((method)quantize_dsp, "dsp", A_CANT, 0);					// Bind method "quantize_dsp" to the DSP call from MSP	addmess((method)quantize_assist, "assist", A_CANT, 0);				// Bind method "quantize_assist" to assistance calls	addmess((method)inspector_open, "info", A_CANT, 0);				// bind method for opening the license window		dsp_initclass();												// Setup object's class to work with MSP	alias("quantize~");											// ...for backwards compatibility	post("tap.quantize~ v1.4 - Copyright © 1999-2001 by Timothy A. Place");	// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *quantize_new(float value){	t_quantize *x = (t_quantize *)newobject(quantize_class);	dsp_setup((t_pxobject *)x, 1);				// Create Object and 1 Inlet (last argument)	outlet_new((t_pxobject *)x, "signal");		// Create an Outlet	x->b_value = value;						// Init the typed in argument	return x;								// Return the pointer}/************************************************************************************/// Methods bound to input/inlets// Method for Assistance Messagesvoid quantize_assist(t_quantize *x, void *b, long msg, long arg, char *dst){	if(msg==1) 	// Inlets		strcpy(dst, "(signal) To be quantized"); 	else if(msg==2) // Outlets		strcpy(dst, "(signal) Quantization Result");}// Memory Deallocationvoid quantize_free(t_quantize *x){	notify_free((t_object *)x);	dsp_free((t_pxobject *)x);}// Perform (signal) Methodt_int *quantize_perform(t_int *w){	t_float *in = (t_float *)(w[1]);   		// Input	t_float *out = (t_float *)(w[2]);		// Output   	t_quantize *x = (t_quantize *)(w[3]);	// Pointer	int n = (int)(w[4]);					// Vector Size	long value = x->b_value;				// value is the argument typed into the Max object	double yadda;						// yadda is a temporary storage variable for the input processes			while (n--) 	{		yadda = *in++;		*out++ = roundFunc(yadda, value); 	// Run input through Decimal Rounding Function	}					                           return (w + 5);						// Return a pointer to the NEXT object in the DSP call chain}// DSP Methodvoid quantize_dsp(t_quantize *x, t_signal **sp, short *count){	dsp_add(quantize_perform, 4, sp[0]->s_vec, sp[1]->s_vec, x, sp[0]->s_n); // Add Perform Method to the DSP Call Chain}/************************************************************************************/// Other Functions used by object// Decimal Rounding Functiondouble roundFunc (double incoming, double maxarg){	int tempstore;						// Temporary Storage Variable		if (incoming >= 0.0)				// Two separate routines for positive & negative numbers	{		incoming = incoming * maxarg;	// shift the decimal place over		incoming = incoming + 0.5;		// preparation for truncation		tempstore = incoming;			// truncate - convert to int		incoming = tempstore;			// convert back to double-float		//incoming = incoming * 0.01;	// shift the decimal back to where it belongs - NOTE: DOES NOT YIELD "TESTABLE" SIGNAL VALUES IN MSP!?!?!?	}	else	{		incoming = incoming * maxarg;	// shift the decimal place over		incoming = incoming - 0.5;		// preparation for truncation		tempstore = incoming;			// truncate - convert to int		incoming = tempstore;			// convert back to double-float		//incoming = incoming * 0.01;	// shift the decimal back to where it belongs - NOTE: DOES NOT YIELD "TESTABLE" SIGNAL VALUES IN MSP!?!?!?	}	return incoming;					// Return rounded value}