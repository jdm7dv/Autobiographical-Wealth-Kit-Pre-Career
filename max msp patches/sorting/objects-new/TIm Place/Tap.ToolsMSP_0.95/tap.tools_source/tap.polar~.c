// MSP External: polar.c// conversion to and from polar coordinates// T.Place - 4/28/2001//		v1.1 (08/27/01) - update for Max/MSP 4//		v1.2 (12/14/01) - minor revisions#include "ext.h"				// Required for all Max External Objects#include "z_dsp.h"			// Required for all MSP External Objects#include <math.h>			#include "ext_strings.h"		// Used for the assistance stringsvoid *polar_class;			// Required. Global pointing to this classtypedef struct _polar		// Data Structure for this object{	t_pxobject x_obj;	int polar_mode;			// Current mode	int polar_connect;		// Current connection scheme/perform method} t_polar;// Prototypes for methods: need a method for each incoming message type:t_int *polar_perform(t_int *w);						// An MSP Perform (signal) Methodt_int *polar_perform2(t_int *w);t_int *polar_perform3(t_int *w);t_int *polar_perform4(t_int *w);void polar_dsp(t_polar *x, t_signal **sp, short *count);		// DSP Methodvoid polar_assist(t_polar *x, void *b, long m, long a, char *s);	// Assistance Methodvoid *polar_new(long myArg);							// New Object Creation Methodvoid polar_mode(t_polar *x, int value);					// "mode" methodvoid polar_tellmeeverything(t_polar *x);void polar_free(t_polar *x);/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&polar_class, (method)polar_new, (method)polar_free, (short)sizeof(t_polar), 0L, A_DEFLONG, 0);	    						addmess((method)polar_dsp, "dsp", A_CANT, 0);					// Bind method "polar_dsp" to the DSP call from MSP	addmess((method)polar_assist,"assist", A_CANT, 0);				// Bind method "polar_assist" to assistance calls	addmess((method)polar_mode,"mode", A_LONG, 0);					// Bind mode method	addmess((method)polar_tellmeeverything,"tellmeeverything", 0);		// 	addmess((method)inspector_open, "info", A_CANT, 0);				// bind method for opening the license window		dsp_initclass();												// Setup object's class to work with MSP	alias("tap.fft_amp~");										// ...for backwards compatibility	post("tap.polar~ v1.2 - Copyright © 2001 by Timothy A. Place");		// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *polar_new(long myArg){	t_polar *x = (t_polar *)newobject(polar_class);	dsp_setup((t_pxobject *)x,2);	outlet_new((t_object *)x, "signal");	outlet_new((t_object *)x, "signal");	x->polar_mode = myArg;				// default mode	return (x);}/************************************************************************************/// Methods bound to input/inlets// Method for Assistance Messagesvoid polar_assist(t_polar *x, void *b, long msg, long arg, char *dst){	if(msg==1){ 	// Inlets		switch(arg){			case 0: strcpy(dst, "(signal) Mode0-Real / Mode1-Magnitude"); break;			case 1: strcpy(dst, "(signal) Mode0-Imaginary / Mode1-Phase"); break;		}	}	else if(msg==2){ // Outlets		switch(arg){			case 0: strcpy(dst, "(signal) Mode0-Maginitudel / Mode1-Real"); break;			case 1: strcpy(dst, "(signal) Mode0-Phase / Mode1-Imaginary"); break;		}	}}// mode methodvoid polar_mode(t_polar *x, int value){	x->polar_mode = value;}// tellmeeverythingvoid polar_tellmeeverything(t_polar *x){	post("     ");	post("     tap.polar - tellmeeverything");	if(x->polar_mode)    		post("     Current Mode is 1 - Polar to Rectangular");	else		post("     Current Mode is 0 - Rectangular to Polar");	switch (x->polar_connect) 	{		case 1:			post("     Current DSP Connection: All inlets and outlets");			break;		case 2:			post("     Current DSP Connection: 1st inlet and both outlets");			break;		case 3:			post("     Current DSP Connection: Both inlets and 1st outlet");			break;		case 4:			post("     Current DSP Connection: Both inlets and 2nd outlet");			break;	}		post("     ");}// Memory Deallocationvoid polar_free(t_polar *x){	notify_free((t_object *)x);	dsp_free((t_pxobject *)x);}// Perform (signal) Method - All inlets and outletst_int *polar_perform(t_int *w){	t_float *in, *in2, magnitude, phase, real, imaginary, *out, *out2;	int n;	t_polar *x = (t_polar *)(w[1]);			in = (t_float *)(w[2]);	in2 = (t_float *)(w[3]);	out = (t_float *)(w[4]);	out2 = (t_float *)(w[5]);	n = (int)(w[6]);		if (x->x_obj.z_disabled) goto out;			while (--n) 	{		if (x->polar_mode) 	// Polar to Rectangular		{			magnitude = *++in;			phase = *++in2;			real = magnitude * cos(phase);			imaginary = magnitude * sin(phase);			*++out = real;			*++out2 = imaginary;			}		else				// Rectangular to Polar		{			real = *++in;			imaginary = *++in2;			magnitude = sqrt((real * real) + (imaginary * imaginary));						if (real == 0)				real = 0.000001;				// prevent divide by zero			phase = atan(imaginary / real);				if ((real < 0) && (imaginary < 0))		// arctangent corrections				phase = phase - 3.14159265;			else if ((real < 0) && (imaginary >= 0))				phase = phase + 3.14159265;			*++out = magnitude;			*++out2 = phase;			}	}out:    return (w+7);}// Perform (signal) Method - Only first inlet, but both outletst_int *polar_perform2(t_int *w){	t_float *in, magnitude, phase, real, imaginary, *out, *out2;	int n;	t_polar *x = (t_polar *)(w[1]);			in = (t_float *)(w[2]);	out = (t_float *)(w[3]);	out2 = (t_float *)(w[4]);	n = (int)(w[5]);		if (x->x_obj.z_disabled) goto out;			while (--n) 	{		if (x->polar_mode) 	// Polar to Rectangular		{			magnitude = *++in;			phase = 0;			real = magnitude * cos(phase);			imaginary = magnitude * sin(phase);			*++out = real;			*++out2 = imaginary;			}		else				// Rectangular to Polar		{			real = *++in;			imaginary = 0;			magnitude = sqrt((real * real) + (imaginary * imaginary));						if (real == 0)				real = 0.000001;				// prevent divide by zero			phase = atan(imaginary / real);				if ((real < 0) && (imaginary < 0))		// arctangent corrections				phase = phase - 3.14159265;			else if ((real < 0) && (imaginary >= 0))				phase = phase + 3.14159265;			*++out = magnitude;			*++out2 = phase;			}	}out:    return (w+6);}// Perform (signal) Method - Both inlets and first outlett_int *polar_perform3(t_int *w){	t_float *in, *in2, magnitude, phase, real, imaginary, *out;	int n;	t_polar *x = (t_polar *)(w[1]);			in = (t_float *)(w[2]);	in2 = (t_float *)(w[3]);	out = (t_float *)(w[4]);	n = (int)(w[5]);		if (x->x_obj.z_disabled) goto out;			while (--n) 	{		if (x->polar_mode) 	// Polar to Rectangular		{			magnitude = *++in;			phase = *++in2;			real = magnitude * cos(phase);			*++out = real;		}		else				// Rectangular to Polar		{			real = *++in;			imaginary = *++in2;			magnitude = sqrt((real * real) + (imaginary * imaginary));						*++out = magnitude;		}	}out:	return (w+6);}// Perform (signal) Method - Both inlets and second outlett_int *polar_perform4(t_int *w){	t_float *in, *in2, magnitude, phase, real, imaginary, *out2;	int n;	t_polar *x = (t_polar *)(w[1]);			in = (t_float *)(w[2]);	in2 = (t_float *)(w[3]);	out2 = (t_float *)(w[4]);	n = (int)(w[5]);		if (x->x_obj.z_disabled) goto out;			while (--n) 	{		if (x->polar_mode) 	// Polar to Rectangular		{			magnitude = *++in;			phase = *++in2;			imaginary = magnitude * sin(phase);			*++out2 = imaginary;			}		else				// Rectangular to Polar		{			real = *++in;			imaginary = *++in2;						if (real == 0)				real = 0.000001;				// prevent divide by zero			phase = atan(imaginary / real);				if ((real < 0) && (imaginary < 0))		// arctangent corrections				phase = phase - 3.14159265;			else if ((real < 0) && (imaginary >= 0))				phase = phase + 3.14159265;			*++out2 = phase;			}	}out:	return (w+6);}// DSP Methodvoid polar_dsp(t_polar *x, t_signal **sp, short *count){	if((count[0]) && (count[1]) && (count[2]) && (count[3]))  // All Inlets & Outlets connected	{   		dsp_add(polar_perform, 6, x, sp[0]->s_vec-1, sp[1]->s_vec-1, sp[2]->s_vec-1, sp[3]->s_vec-1, sp[0]->s_n + 1);   		x->polar_connect = 1;   	}	   	else if((count[0]) && (count[2]) && (count[3]))  // Only first inlet, and both Outlets connected   	{   		dsp_add(polar_perform2, 5, x, sp[0]->s_vec-1, sp[2]->s_vec-1, sp[3]->s_vec-1, sp[0]->s_n + 1);   		x->polar_connect = 2;    	}	  		   	else if((count[0]) && (count[1]) && (count[2]))  // Both inlets, and first Outlet connected   	{   		dsp_add(polar_perform3, 5, x, sp[0]->s_vec-1, sp[1]->s_vec-1, sp[2]->s_vec-1, sp[0]->s_n + 1);   		x->polar_connect = 3;     	}	 		   	else if((count[0]) && (count[1]) && (count[3]))  // Both inlets, and second Outlet connected   	{   		dsp_add(polar_perform4, 5, x, sp[0]->s_vec-1, sp[1]->s_vec-1, sp[3]->s_vec-1, sp[0]->s_n + 1);   		x->polar_connect = 4;    	}	  		   	else   	{   		dsp_add(polar_perform, 6, x, sp[0]->s_vec-1, sp[1]->s_vec-1, sp[2]->s_vec-1, sp[3]->s_vec-1, sp[0]->s_n + 1);   		x->polar_connect = 1;      	}		}