// MSP External: fftlist~.c// Converts spectral data from signal stream to a list// T.Place - 5/13/2001//		v1.1 (08/27/2001) - update for Max/MSP 4//		v2.0 (01/08/2002) - change output method (scheduled), other minor improvements#include "ext.h"					// Required for all Max External Objects#include "z_dsp.h"				// Required for all MSP External Objects#include "ext_strings.h"			// Used for the assistance strings#define VERSION "tap.fft-list~ v2.0 - Copyright © 2001-2002 by Timothy A. Place"#define MAXSIZE 2048	void *fftlist_class;				// Required. Global pointing to this classtypedef struct _fftlist				// Data Structure for this object{	t_pxobject x_obj;				// Header;  Must always be the first field; used by MSP	int s_bins;		    				// Value from the typed in argument   	void *fftlist_out;				// Pointer to outlet. need one for each outlet    	Atom fft_compiled[MAXSIZE];		// Compiled list of spectral data - based on MSP's FFT limit of 4096   	float fftlist_mult;				// scaling factor   	int fftlist_nyquist;				// truncate at nyquist?   	int fftlist_autopoll;				// Automatically spit the data?   	void	*fftlist_clock;				// Pointer to the clock object} t_fftlist;// Prototypes for methods: need a method for each incoming message typevoid *fftlist_new(long value);								// New Object Creation Methodt_int *fftlist_perform(t_int *w);							// An MSP Perform (signal) Methodvoid fftlist_dsp(t_fftlist *x, t_signal **sp, short *count);			// DSP Methodvoid fftlist_assist(t_fftlist *x, void *b, long m, long a, char *s);		// Assistance Methodvoid fftlist_bang(t_fftlist *x);								// void fftlist_mult(t_fftlist *x, float value);						// void fftlist_nyquist(t_fftlist *x, long value);						// void fftlist_autopoll(t_fftlist *x, long value);					// void fftlist_free(t_fftlist *x);								// /************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&fftlist_class, (method)fftlist_new, (method)fftlist_free, (short)sizeof(t_fftlist), 0L, A_LONG, 0);	addmess((method)fftlist_dsp, "dsp", A_CANT, 0);				// Bind method "fftlist_dsp" to the DSP call from MSP	addmess((method)fftlist_assist, "assist", A_CANT, 0);			// Bind method "fftlist_assist" to assistance calls	addmess((method)fftlist_bang, "bang", 0);	addmess((method)fftlist_mult, "mult", A_FLOAT, 0);	addmess((method)fftlist_nyquist, "nyquist", A_LONG, 0);	addmess((method)fftlist_autopoll, "autopoll", A_LONG, 0);	addmess((method)inspector_open, "info", A_CANT, 0);			// bind method for opening the license window		dsp_initclass();										// Setup object's class to work with MSP	post(VERSION, 0);									// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *fftlist_new(long value){	t_fftlist *x = (t_fftlist *)newobject(fftlist_class);	dsp_setup((t_pxobject *)x, 2);						// Create Object and 2 Inlets 	x->fftlist_out = listout(x);							// Create a list Outlet 	x->fftlist_clock = clock_new(x, (method)fftlist_bang);		// Create the queue clock	x->s_bins = value;								// Number of bins in analysis	x->fftlist_mult = 1.;								// 	x->fftlist_nyquist = 1;							// 	x->fftlist_autopoll = 1;							// 	return x;										// Return pointer}/************************************************************************************/// Methods bound to input/inlets// Method for Assistance Messagesvoid fftlist_assist(t_fftlist *x, void *b, long msg, long arg, char *dst){	if(msg==1){ 	// Inlets		switch(arg){			case 0: strcpy(dst, "(signal) Input from FFT"); break;			case 1: strcpy(dst, "(signal) Index from FFT"); break;		}	}	else if(msg==2) // Outlets		strcpy(dst, "(list) the data frame-by-frame");}// Mult methodvoid fftlist_mult(t_fftlist *x, float value){	x->fftlist_mult = value;}// Nyquist methodvoid fftlist_nyquist(t_fftlist *x, long value){	x->fftlist_nyquist = value;}// Autopoll set...void fftlist_autopoll(t_fftlist *x, long value){	x->fftlist_autopoll = value;}// Memory Deallocationvoid fftlist_free(t_fftlist *x){	clock_unset(x->fftlist_clock);		// remove the clock routine from the scheduler	clock_free(x->fftlist_clock);		// free the clock memory	notify_free((t_object *)x);	dsp_free((t_pxobject *)x);}// Listout Methodvoid fftlist_bang(t_fftlist *x){	if (x->fftlist_nyquist == 0) 		outlet_list(x->fftlist_out, 0L, x->s_bins, x->fft_compiled);	else	 	outlet_list(x->fftlist_out, 0L, x->s_bins * 0.5, x->fft_compiled);}// Perform (signal) Methodt_int *fftlist_perform(t_int *w){	t_float *in = (t_float *)(w[1]);		// Spectral data Input  	t_float *in2 = (t_float *)(w[2]);	// Index Input		   	t_fftlist *x = (t_fftlist *)(w[3]);	//  Object Pointer	int n = (int)(w[4]);				// "Vector" Size	float value; 	int index, bins = x->s_bins - 1, changeFlag = 0; 	double index2;  	if (x->x_obj.z_disabled) goto byebye;	while (--n)	{		value = *++in;		index2 = *++in2;		index = index2 + 0.49;			value = value * x->fftlist_mult;				// Amplify values as desired		SETFLOAT(x->fft_compiled + index, value);		if (index == bins) changeFlag = 1;			// and we are at the last index	}	if((changeFlag == 1)&&(x->fftlist_autopoll != 0)) 		clock_delay(x->fftlist_clock, 0);				// Set clock to go off ASAPbyebye:		return (w + 5);								// return pointer to NEXT object in dsp chain}// DSP Methodvoid fftlist_dsp(t_fftlist *x, t_signal **sp, short *count){	dsp_add(fftlist_perform, 4, sp[0]->s_vec-1, sp[1]->s_vec-1, x, sp[0]->s_n+1);	// Add Perform (signal) Method to the DSP Call Chain}