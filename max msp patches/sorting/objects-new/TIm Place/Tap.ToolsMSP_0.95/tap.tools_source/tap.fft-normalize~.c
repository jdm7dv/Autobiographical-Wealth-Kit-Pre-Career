// MSP External: fft-normalize~.c// Normalize spectral data from fft~// T.Place - 5/13/2001//		v1.1 (08/27/2001) - update for Max/MSP 4//		v1.2 (11/30/2001) - minor revisions#include "ext.h"				// Required for all Max External Objects#include "z_dsp.h"			// Required for all MSP External Objects#include "ext_strings.h"		// Used for the assistance stringsvoid *fftnorm_class;			// Required. Global pointing to this classtypedef struct _fftnorm		// Data Structure for this object{	t_pxobject x_obj;		// Header;  Must always be the first field; used by MSP	int s_bins;		    		// Value from the typed in argument	int s_bins2;} t_fftnorm;// Prototypes for methods: need a method for each incoming message typevoid *fftnorm_new(long value);									// New Object Creation Methodt_int *fftnorm_perform(t_int *w);								// An MSP Perform (signal) Methodvoid fftnorm_dsp(t_fftnorm *x, t_signal **sp, short *count);			// DSP Methodvoid fftnorm_assist(t_fftnorm *x, void *b, long m, long a, char *s);		// Assistance Methodvoid fftnorm_free(t_fftnorm *x);/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{    setup((t_messlist **)&fftnorm_class, (method)fftnorm_new, (method)fftnorm_free, (short)sizeof(t_fftnorm), 0L, A_LONG, 0);	addmess((method)fftnorm_dsp, "dsp", A_CANT, 0);					// Bind method "fftnorm_dsp" to the DSP call from MSP	addmess((method)fftnorm_assist, "assist", A_CANT, 0);				// Bind method "fftnorm_assist" to assistance calls	addmess((method)inspector_open, "info", A_CANT, 0);				// bind method for opening the license window		dsp_initclass();												// Setup object's class to work with MSP	post("tap.fft-normalize~ v1.2 - Copyright © 2001 by Timothy A. Place");	// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *fftnorm_new(long value){	t_fftnorm *x = (t_fftnorm *)newobject(fftnorm_class);	dsp_setup((t_pxobject *)x, 3);						// Create Object and 2 Inlets	outlet_new((t_object *)x, "signal");					// Create a signal outlet 	outlet_new((t_object *)x, "signal");					// Create a signal outlet 	x->s_bins = value;								// Number of bins in analysis	return x;										// Return pointer}/************************************************************************************/// Methods bound to input/inlets// Method for Assistance Messagesvoid fftnorm_assist(t_fftnorm *x, void *b, long msg, long arg, char *dst){	if(msg==1){ 	// Inlets		switch(arg){			case 0: strcpy(dst, "(signal) Real input from FFT"); break;			case 1: strcpy(dst, "(signal) Imaginary input from FFT"); break;			case 2: strcpy(dst, "(signal) Index from FFT"); break;		}	}	else if(msg==2){ // Outlets		switch(arg){			case 0: strcpy(dst, "(signal) Normalized real output"); break;			case 1: strcpy(dst, "(signal) Normalized imaginary output"); break;		}	}}// Memory Deallocationvoid fftnorm_free(t_fftnorm *x){	notify_free((t_object *)x);	dsp_free((t_pxobject *)x);}// Perform (signal) Methodt_int *fftnorm_perform(t_int *w){	t_float *in = (t_float *)(w[1]);			// Real	t_float *in2 = (t_float *)(w[2]);		// Imaginary	t_float *in3 = (t_float *)(w[3]);		// Index	t_float *out = (t_float *)(w[4]);		// Real Out	t_float *out2 = (t_float *)(w[5]);		// Imaginary Out		   	t_fftnorm *x = (t_fftnorm *)(w[6]);		//  Object Pointer	int n = (int)(w[7]);					// "Vector" Size	double val;	double val2;	double index; 	int bins = x->s_bins - 1; 	while (--n)	{		val = *++in;		val2 = *++in2;		index = *++in3;			index = index + 0.49; 				val = val / x->s_bins2;		val2 = -val2 / x->s_bins2;				if (index == 0 || index == bins)			val = val * 0.5;		*++out = val;		*++out2 = val2;			}	return (w + 8);						// return pointer to NEXT object in dsp chain}// DSP Methodvoid fftnorm_dsp(t_fftnorm *x, t_signal **sp, short *count){	x->s_bins2 = x->s_bins / 2;	dsp_add(fftnorm_perform, 7, sp[0]->s_vec-1, sp[1]->s_vec-1, sp[0]->s_vec-1, 		sp[1]->s_vec-1, sp[1]->s_vec-1, x, sp[0]->s_n+1);	// Add Perform (signal) Method to the DSP Call Chain}