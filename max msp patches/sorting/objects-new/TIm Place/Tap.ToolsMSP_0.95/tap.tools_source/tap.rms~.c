// MSP External: tap.rms~.c// RMS envelope following// T.Place - 03.31.2001//		v1.3 (08/27/01) - update for Max/MSP 4//		v1.4 (12/14/01) - minor revisions#include "ext.h"				// Required for all Max External Objects#include "z_dsp.h"			// Required for all MSP External Objects#include <math.h>			// Required for sqrt function#include "ext_strings.h"		// Used for the assistance stringsvoid *rms_class;			// Required. Global pointing to this classtypedef struct _rms			// Data Structure for this object{	t_pxobject x_obj;	double	rms_coef, rms_feedback;} t_rms;// Prototypes for methods: need a method for each incoming message typevoid *rms_new(void);								// New Object Creation Methodt_int *rms_perform(t_int *w);							// An MSP Perform (signal) Methodvoid rms_dsp(t_rms *x, t_signal **sp, short *count);		// DSP Methodvoid rms_assist(t_rms *x, void *b, long m, long a, char *s);	// Assistance Methodvoid rms_float(t_rms *x, float coef);					// Bang Methodvoid rms_free(t_rms *x);float fclip(float a, float b, float c);/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&rms_class, (method)rms_new, (method)rms_free, (short)sizeof(t_rms), 0L, 0);	addmess((method)rms_dsp, "dsp", A_CANT, 0);					// Bind method "rms_dsp" to the DSP call from MSP	addmess((method)rms_assist, "assist", A_CANT, 0);				// Bind method "rms_assist" to assistance calls	addfloat((method)rms_float);									// Bind coef method to float input	addmess((method)inspector_open, "info", A_CANT, 0);				// bind method for opening the license window		dsp_initclass();												// Setup object's class to work with MSP	alias("rms~");												// ...for backwards compatibility	post("tap.rms~ v1.4 - Copyright © 2001 by Timothy A. Place");			// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *rms_new(void){	t_rms *x = (t_rms *)newobject(rms_class);		dsp_setup((t_pxobject *)x,1);				// Create Object and 1 Inlet (last argument)	outlet_new((t_pxobject *)x, "signal");		// Create a signal Outlet	x->rms_coef = 0.9995;					// Default feedback coef.	x->rms_feedback = 0;					// Init the feedback sample	return (x);							// Return the pointer}/************************************************************************************/// Methods bound to input/inlets// Method for Assistance Messagesvoid rms_assist(t_rms *x, void *b, long msg, long arg, char *dst){	if(msg==1) 		// Inlet		strcpy(dst, "(signal) Input");	else if(msg==2) 	// Outlet		strcpy(dst, "(signal) Envelope");}// float Methodvoid rms_float(t_rms *x, float coef)	{	x->rms_coef = fclip(coef, 0.00001, 0.99999);}// Memory Deallocationvoid rms_free(t_rms *x){	notify_free((t_object *)x);	dsp_free((t_pxobject *)x);}// Perform (signal) Methodt_int *rms_perform(t_int *w){	t_float *in = (t_float *)(w[1]);   		// Input	t_float *out = (t_float *)(w[2]);		// Output   	t_rms *x = (t_rms *)(w[3]);			// Pointer	int n = (int)(w[4]);					// Vector Size		double xx;							// (used to carry input)	double fb = x->rms_feedback;			// feedback sample for lopass filter	float coef = x->rms_coef;				// feedback Coef			if (x->x_obj.z_disabled) return (w+5);	while (--n) 	{		xx = *++in;					// Input		xx = xx * xx;					// Square				xx = (xx * (1 - coef)) + (fb * coef);	// Mean (Filter)...			fb = xx;								xx = sqrt(xx);					// Root								*++out = xx;					// Output	}		x->rms_feedback = fb;				// Store Feedback Sample	return (w + 5);						// Return a pointer to the NEXT object in the DSP call chain}// DSP Methodvoid rms_dsp(t_rms *x, t_signal **sp, short *count){	x->rms_feedback = 0;											// Init the feedback sample	dsp_add(rms_perform, 4, sp[0]->s_vec-1, sp[1]->s_vec-1, x, sp[0]->s_n+1);	// Add Perform Method to the DSP Call Chain}/************************************************************************************/// Other Functions used by object// Utility function to limit numbersfloat fclip(float a, float b, float c){	return a < b? b: (a > c? c : a);}