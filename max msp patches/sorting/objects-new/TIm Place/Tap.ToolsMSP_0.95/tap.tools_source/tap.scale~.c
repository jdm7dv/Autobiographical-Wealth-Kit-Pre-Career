// MSP External: scale~.c// An MSP complement to the MAX scale object// T.Place - 4/29/2001//		v1.1 (09/01/01) - update for Max/MSP 4//		v1.2 (12/14/01) - minor revisions// The exponential base option of the Jimmies' object has not yet been implemented.  // Any suggestions on how to do so would be greatly appreciated...#include "ext.h"				// Required for all Max External Objects#include "z_dsp.h"			// Required for all MSP External Objects	#include <math.h>		#include "ext_strings.h"		// Used for the assistance stringsvoid *scale_class;			// Required. Global pointing to this classtypedef struct _scale		// Data Structure for this object{	t_pxobject x_obj;		// Header;  Must always be the first field; used by MSP	float s_inlow;			// low value from the typed in argument	float s_inhigh;			// high value from the typed in argument	float s_outlow;	float s_outhigh;	float s_inscale;	float s_outdiff;	short x_connected[4];} t_scale;// Prototypes for methods: need a method for each incoming message typevoid *scale_new(Symbol *s, short argc, Atom *argv);			// New Object Creation Methodt_int *scale_perform(t_int *w);							// An MSP Perform (signal) Methodt_int *scale_perform2(t_int *w);void scale_dsp(t_scale *x, t_signal **sp, short *count);			// DSP Methodvoid scale_assist(t_scale *x, void *b, long m, long a, char *s);		// Assistance Methodvoid scale_float(t_scale *x, double val);void scale_free(t_scale *x);/************************************************************************************/// Main() Functionvoid main(void)				// main recieves a copy of the Max function macros table{	setup((t_messlist **)&scale_class, (method)scale_new, (method)scale_free, (short)sizeof(t_scale), 0L, A_GIMME, 0);	addmess((method)scale_dsp, "dsp", A_CANT, 0);					// Bind method "scale_dsp" to the DSP call from MSP	addmess((method)scale_assist, "assist", A_CANT, 0);				// Bind method "scale_assist" to assistance calls	addfloat((method)scale_float);									// 	addmess((method)inspector_open, "info", A_CANT, 0);				// bind method for opening the license window		dsp_initclass();												// Setup object's class to work with MSP	alias("scale~");												// ...for backwards compatibility	post("tap.scale~ v1.2 - Copyright © 2001 by Timothy A. Place");		// Print to the Max Window...	post("     Impact Center @ University of Missouri - Kansas City / Silicon Prairie Intermedia");}/************************************************************************************/// Object Creation Methodvoid *scale_new(Symbol *s, short argc, Atom *argv){	t_scale *x = (t_scale *)newobject(scale_class);	if(argc){								// Initialize the following if there are arguments...		x->s_inlow = argv[0].a_w.w_float;			x->s_inhigh = argv[1].a_w.w_float;			x->s_outlow = argv[2].a_w.w_float;				x->s_outhigh = argv[3].a_w.w_float;	}    else{									// Initialize the following if there are no arguments...		x->s_inlow = 0;			x->s_inhigh = 127;				x->s_outlow = 0;				x->s_outhigh  = 1;	     }	dsp_setup((t_pxobject *)x, 5);				// Create Object with 5 Inlets (input, inlow, inhigh, outlow, outhigh)   	outlet_new((t_object *)x, "signal");			// Create a signal outlet    	x->s_inscale = 1 / (x->s_inhigh - x->s_inlow);	x->s_outdiff = x->s_outhigh - x->s_outlow;	return x;								// Return pointer}/************************************************************************************/// Methods bound to input/inlets// Method for Assistance Messagesvoid scale_assist(t_scale *x, void *b, long msg, long arg, char *dst){	if(msg==1){ 	// Inlets		switch(arg){			case 0: strcpy(dst, "(signal) value to be scaled"); break;			case 1: strcpy(dst, "(signal/float) low input value"); break;			case 2: strcpy(dst, "(signal/float) high input value"); break;			case 3: strcpy(dst, "(signal/float) low output value"); break;			case 4: strcpy(dst, "(signal/float) high output value"); break;			case 5: strcpy(dst, "(signal/float) exponential base value"); break;		}	}	else if(msg==2) // Outlets		strcpy(dst, "(signal) scaled output value");}// Method for float inputvoid scale_float(t_scale *x, double val){	switch (x->x_obj.z_in){		case 1:			x->s_inlow = val;			x->s_inscale = 1 / (x->s_inhigh - x->s_inlow);			break;		case 2:			x->s_inhigh = val;			x->s_inscale = 1 / (x->s_inhigh - x->s_inlow);			break;		case 3:			x->s_outlow = val;			x->s_outdiff = x->s_outhigh - x->s_outlow;			break;		case 4:			x->s_outhigh = val;			x->s_outdiff = x->s_outhigh - x->s_outlow;			break;	}}// Memory Deallocationvoid scale_free(t_scale *x){	notify_free((t_object *)x);	dsp_free((t_pxobject *)x);}// Perform (signal) Method for 1 input signalt_int *scale_perform(t_int *w){	t_float *in1 = (t_float *)(w[1]);					// Input 1	t_float *out1 = (t_float *)(w[2]);					// Output 1   	t_scale *x = (t_scale *)(w[3]);						//  Object Pointer	int n = (int)(w[4]);								// "Vector" Size	float value;									//  Variable for temporary storage 	while (n--)	{		value = *in1++;		value = (value - x->s_inlow) * x->s_inscale;		value = (value * x->s_outdiff) + x->s_outlow;		*out1++ = value;												}    return (w + 5);									// return pointer to NEXT object in dsp chain}// Perform method for multiple signal inputt_int *scale_perform2(t_int *w){	float value, inscale, outdiff;	t_scale *x = (t_scale *)(w[1]);						//  Object Pointer	t_float *in1 = (t_float *)(w[2]);					// Input 1 	float inlow = x->x_connected[1]? *(t_float *)(w[3]) : x->s_inlow;	float inhigh = x->x_connected[2]? *(t_float *)(w[4]) : x->s_inhigh;	float outlow = x->x_connected[3]? *(t_float *)(w[5]) : x->s_outlow;	float outhigh = x->x_connected[4]? *(t_float *)(w[6]) : x->s_outhigh;	t_float *out1 = (t_float *)(w[7]);					// Output 1	int n = (int)(w[8]);								// "Vector" Size	if (x->x_obj.z_disabled) goto out;  	inscale = 1 / (inhigh - inlow); 	outdiff = outhigh - outlow; 	while (n--)	{		value = *in1++;		value = (value - inlow) * inscale;		value = (value * outdiff) + outlow;		*out1++ = value;												}out:	return (w + 9);									// return pointer to NEXT object in dsp chain}// DSP Methodvoid scale_dsp(t_scale *x, t_signal **sp, short *count){	if((count[1]) || (count[2]) || (count[3]) || (count[4])){	 	x->x_connected[1] = count[1];		x->x_connected[2] = count[2];		x->x_connected[3] = count[3];		x->x_connected[4] = count[4]; 			dsp_add(scale_perform2, 8, x, sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[3]->s_vec, sp[4]->s_vec,			sp[5]->s_vec, sp[0]->s_n);			}	else		dsp_add(scale_perform, 4, sp[0]->s_vec, sp[5]->s_vec, x, sp[0]->s_n);	}