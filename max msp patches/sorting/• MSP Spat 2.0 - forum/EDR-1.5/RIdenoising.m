function [Tr,P0,TLim,PNoise, Tbegin,RI,RItime,RIsynt, STFT, STFTfreq, STFTtime,EDR]= RIdenoising(varargin)% [Tr,P0,TLim,PNoise, Tbegin, RI, RItime, RIsynt,STFT, STFTfreq, STFTtime,EDR]%                                            = RIdenoising(mode,{submode}, data);%% Eliminates the noise in a Room Impulse response, using a Energy Decay Relief % analysis.For each frequency channel, the end of the Energy decay curve is % replaced by an artificial signal (white noise with a decreasing exponential % value). Then the inverse Fourier transform is computed, allowing to obtain% a denoised room impulse response%% The 'mode' parameters allows this function to be called in different ways. % Values can be%         's' or 'straight' : parameters or given directly%         'f' or 'file'     : read the parameters in a file%         'd' or  'dir'     : do the analysis for an entire directory (reserved for %                             future versions)%% +'straight' mode has 2 submodes :%     * 'n' or 'name' : a filename is given with its extension, and then opened %        (for more explanations about reading sound files see sigRead). Only mono %        files are accepted. An example call would be :%    RIdenoising('s', 'n', 'myfilein','myfileout',{'win_type', nfft, overlap,Trev,NRepeat}) %%     *'d' or 'data' : data are given directly;%       Data are directly given. These data are : the signal (Sig), the time scale%       associated with the signal (Time), and the sampling rate of the signal (sr).%       If one of these 3 data was missing, an error message would be output.%    RIdenoising('s', 'd', Sig,Time, sr,'myfileout', {'win_type', nfft, Trev, NRepeat}) %  % +'file' mode allows parameters to be read from a file. Only filenames can%   be stored (no data). In this mode an option to save the result of EDRanalysis%   in a Matlab file (.mat) is permitted. In order to select the data to save, a %   filter can be precised. See the example file 'data.m', and more about%   filters in the 'README' file.%    RIdenoising('f','filedata.m');% % *'dir' mode allows to batch the operation on a complete directory. This mode%   will be available only in future version of EDR.%% Possible input are : % 'myfilein' : name  of thefile containing the impulse response to be cleaned%              Must have an extension. Obligatory field!% 'myfileout': file name of the cleaned output signal. Must have an extension % win_type   : name of the kind of window used for short-timr Fourier transform%              analysis. Choices are 'harris', 'triang', 'bartlett', 'kaiser','blackman'.%              'hamming', 'hanning'. Default is 'harris'. % nfft       : number of FFT points; default = 512% overlap    : overlap rate of the windows in STFT; default is 0.75% Trev       : time (ms) where the reverberation begins (referenced to direct sound)%              default is 100 ms    % Nrepeat    : number of iterations in the computing process (default is 12)%% Output are : % Tr       : reverberation time (versus frequency)% P0       : initial Power Spectrum (versus frequency)% TLim     : limit time (Noise level = Signal level)% PNoise   : noise level (versus frequency)% Tbegin   : arrival time of the direct sound% RI       : initial ipulse response% RItime   : time scale for the impulse response% RIsynt   : restored impulse response% STFT     : Short time Fourier transfoem of the signal% STFTFreq : frequency scale associated with STFT% STFTtime : temporal scale associated with STFT% EDR      : Energy Decay Relief%% The output signal can be saved in another file format but sampling rate can't% be changed.%% See also : EDRanalysis, EDRanalysis, edr, stft, RI2Spaterror(nargchk(1, 10,nargin));RI = []; RItime =[]; RIsynt=[];Tr=[];P0=[];TLim=[];PNoise=[];Tbegin=[];STFT=[];STFTFreq=[]; STFTtime=[];EDR =[];finalfilter = [];[msg, sigName,nameout, RI, RItime,sr,wintype,nfft,overlap, Trev, Nrepeat, saveFlag, keepfilter, modality] = RIdeno_Check(varargin);if(strcmp(modality, 'file') | strcmp(modality , 'f'))    filename = char(varargin(2));    A_nfft = []; A_winname = []; A_overlap = []; A_Trev = []; A_Nrepeat = [];    A_sigName =[]; A_nameout =[];    saveFlag=[];    keepfilter=[];      %Check directory    punktnb = 0;parser = 1;    while(strcmp(filename(parser),'.'))      parser = parser+1;    end      punktnb = parser-1;    if(punktnb ~= 0)      msg = 'Matlab behavior requires you to have the config file in the current directory';      error(msg);    end       %get shortname    [t r] = strtok(filename, '.');    if(isempty(r))      t = filename;    end    eval(t)    if (isempty(A_sigName))        msg = 'No file name for a signal given in the configuration file!';       error(msg);    else      sigName = A_sigName;    end        if(isempty(A_nameout))        [t r] = strtok(A_sigName, '.');       A_nameout = [t .aif];       fprintf('Using default output name, format is AIFF : %s', nameout)     else      nameout = A_nameout;    end    if(isempty(A_winname)) A_winname = 'harris';end    if(isempty(A_nfft)) A_nfft = 512; end    if(isempty(A_overlap)) A_overlap = 0.75; end    if(isempty(A_Trev)) A_Trev = 100; end    if(isempty(A_Nrepeat)) A_Nrepeat = 12; end      if(~isempty(keepfilter))       saveFlag = 1;   end      if(isempty(saveFlag) | (saveFlag == 0))      saveFlag=0;      keepfilter=[];   else      saveFlag = 1;   end        wintype =  A_winname; nfft = A_nfft; overlap = A_overlap;    Trev = A_Trev; Nrepeat = A_Nrepeat;   endif(~isempty(msg))  Tr=[];P0=[];TLim =[];PNoise=[]; Freq=[]; STFT =[]; STFTtime = []; Tbegin =[];EDR =[];  error(msg)else %  nothingend[finalfilter] = testfilter(keepfilter, sigName);if (isempty(RI))  if(~isempty(sigName));      [RI, RItime,sr, long] = sigRead(sigName);  else       Tr=[];P0=[];TLim =[];PNoise=[]; Freq=[]; STFT =[]; STFTtime = []; Tbegin =[];EDR =[];       msg = 'Error : No data or name is given!';       error(msg);   endendswitch(wintype)  case 'kaiser'   exstring = [wintype '(' num2str(nfft) ',10)'] ;  otherwise   exstring = [wintype '(' num2str(nfft) ')'];endwin = eval(exstring);S = size(win);if(S(1)== 1)  win = win';endnormal = sqrt(sum(win.*win));% Finding the direct signal time[ODtime, ODtimesample]=TimeOD(RI, sr);Tbegin = ODtime;beginTime = ODtime+0.001*Trev;%Calcul du STFT bien norme[STFT, STFTtime, STFTfreq]=stfs(RI, sr, win, nfft, overlap);tfctRI =  stft(RI, sr, win, nfft, overlap);Freq = STFTfreq;% Calcul des parametres de sortieIndex= find(STFTtime>= beginTime);Time = STFTtime(Index);fprintf('Beginning analysis with %d iterations\n',Nrepeat);fprintf('Reverberation time arrival : %d\n', Trev);   for l = 1: (length(STFTfreq)) % fprintf('Computation for frequency %d\r',l); Chan =  STFT(l,:); Chan = Chan(Index); [Tr(l), P0(l), PNoise(l), Error(l)] = EDRanalysis_Initialize(Chan,Time,10, nfft,overlap); %% Recursive loop	 i = 1; while i<Nrepeat+1     OldError = Error(l);    [Tr(l), P0(l), PNoise(l), TLim(l), Error(l), EDR(l), ResVal(l)] = EDRanalysis_Iteration(Chan,Time,Tr(l), P0(l), PNoise(l), nfft,overlap);    DeltaError(i,l) = abs(100*(OldError-Error(l))/Error(l));    i=i+1; endend fprintf('\n');%%PostProcessing[Tr, FalseIndexes] = CleanTr(Freq,Tr);Tr = CorrectVal(Tr, eps);Tr = CorrectVal(Tr, 0);Tr = CorrectNaN(Tr);EDR = CorrectNaN(EDR);ResVal = CorrectNaN(ResVal);PNoise = CleanPN(PNoise);[P0, FalseIndexes] = CleanP0(Freq,P0, Tr,FalseIndexes, EDR, ResVal);P0 = max(P0, PNoise);TLim = -Tr.*log10(PNoise./P0)/6;TLim = CorrectVal(TLim,0);%%Denoising%Get the limit following the limit for 92 dB of resolutionslope = -60./Tr;Pori = PowerLog(P0);LVal = -92;T_92 = (LVal-Pori)./slope;%We stay under 12000 Hz, if there is some problem %in the high frequenciesIndinf = find(Freq < 12000);mT_92 = max(T_92(Indinf));deltat = STFTtime(2)-STFTtime(1);deltatRI = RItime(2)-RItime(1);Ntodo =round(mT_92/deltat) +5;NtodoRI = round(mT_92/deltatRI)+nfft*overlap;fprintf('Doing Fourier transform on a generated random noise\n')%bn = randn(size(RI));bn = randn(1,NtodoRI);[STFTbn, STFTtimebn, STFTfreqbn]=stfs(bn, sr, win, nfft, overlap);[TFCTbn, TFCTtimebn, TFCTfreqbn]=stfs(bn, sr, win, nfft, overlap);sbn = size(STFTbn);sri = size(STFT);stRI = sri(2);stbn = sbn(2);sfreq = sri(1);if(stRI >stbn)  %il faut garder moins  STFT = STFT(:,1:stbn);  STFTtime  = STFTtime(1:stbn);  tfctRI = tfctRI(:,1:stbn);else  %il faut rajouter des 0  diff =  stbn -stRI;  comp = zeros(sfreq, diff);  STFT = [STFT comp];  tfctRI = [tfctRI comp];enda = angle(tfctRI);ab = angle(TFCTbn);long = length(Tr);pol2 = zeros(2, long);pol2(1,:) = -60./Tr;pol2(2,:) = PowerLog(P0); bNoiseIndex = zeros(size(tfctRI));fprintf('Replacing noisy part for each channel\n');for k=1:long    Chan =  STFTbn(k,:);    Pol2 = pol2(:,k);    STFT_bn2(k,:) = PowerExp(polyval(Pol2, STFTtimebn)).*STFTbn(k,:);    Tl = TLim(k);    endtime = STFTtime(length(STFTtime));   if(Tl < endtime)      NoiseIndex= find(STFTtime>= Tl);      bNoiseIndex(k, NoiseIndex) = NoiseIndex;      a(k, NoiseIndex) = ab(k, NoiseIndex);         STFT(k,NoiseIndex) = STFT_bn2(k,NoiseIndex);   endendmod = normal*sqrt(STFT);% the Matlab gag : j is defined before as  something else than sqrt(-1):% answer don't use jphase = exp(j*a);TFCTsynt = mod.*phase; [RIsynt] = istft(STFTtime, STFTfreq, TFCTsynt, nfft, win, overlap);[sODtime, sODtimesample]=TimeOD(RIsynt, sr);RIsynt(1, sODtimesample-1) = zeros(size(RIsynt(1, sODtimesample-1)));[Value]=sigWrite(RIsynt,nameout,sr);if(~isempty(finalfilter)) fprintf('Saving result in impulse response directory\n'); eval(finalfilter);endfunction  [msg, sigName,nameout, RI, RItime,sr,A_winname,A_nfft,A_overlap, A_Trev, Nrepeat, saved, filter, modality]= RIdeno_Check(P);msg = [];sigName = []; nameout=[];RI = []; RItime = []; sr = [];A_winname=[];A_nfft =[];A_overlap =[]; A_Trev =[]; Nrepeat=[];saved=[];filter=[];modality=[];modality = char(P(1));lp = length(P);if(lp == 1)  msg = 'Mode without data leads to nowhere!';  return;endswitch(modality) case {'straight','s'}  submodality = char(P(2));   if(isempty(submodality))     msg = 'In this mode a submode must be given.'     return  end  switch(submodality)     case {'name', 'n'},       fprintf('Call in straight mode, with a filename\n');              %%%%  syntax       %%%%  RIdenoising('s', 'n', 'myfilein','myfileout',{'win_type', nfft, overlap,Trev,NRepeat})       if(lp <3)         msg = 'Some essential data are forgotten for this mode';         return;       end       sigName = char(P(3));       if (isempty(sigName))         msg = 'You must specify a name in name mode, you bugger!';         return;       end               path = '';         r = sigName;         idx = 0;         bsflag = 0;             if(strcmp(sigName(1), '/'))            bsflag = 1;         end         while(~isempty(r))            idx = idx+1;            [t r] = strtok(r,'/');         end             r = sigName;         for i=1:idx-1          [t r] = strtok(r,'/');          if(~isempty(path))            path = [path '/' t];          else            path = t;          end         end        if(~isempty(path))          path = [path '/'];          ln = length(r);          kName = r(2:ln);          if(bsflag == 1)           path = ['/' path];          end        else         kName = r;        end       if(lp >=4)         nameout = char(P(4));             if (isempty(nameout))          [t r] = strtok(kName, '.');          nameout = ['d' t '.aif'];          nameout = [path nameout];                    fprintf('No output name provided. File will be saved as AIFF : %s\n', nameout);         end       else        [t r] = strtok(sigName, '.');        [t r] = strtok(kName, '.');        nameout = ['d' t '.aif'];        nameout = [path nameout];                  fprintf('No output name provided. File will be saved as AIFF : %s\n', nameout);       end       if(lp >=5) A_winname = char(P(5)); else,A_winname = 'harris';end       if(isempty(A_winname)) A_winname = 'harris';end       if(lp >=6) v = P(6); A_nfft = cat(1, v{:}); else A_nfft = 512; end        if(isempty(A_nfft)) A_nfft = 512; end        if(lp >=7) v = P(7); A_overlap = cat(1, v{:}); else A_overlap = 0.75; end        if(isempty(A_overlap)) A_overlap = 0.75; end       if(lp >=8) v = P(8); A_Trev = cat(1, v{:}); else A_Trev = 100; end       if(isempty(A_Trev)) A_Trev = 100; end       if(lp >=9) v = P(9); Nrepeat = cat(1, v{:}); else Nrepeat = 12; end       if(isempty(Nrepeat)) Nrepeat = 12; end       if(lp >=10) fprintf('Warning : Too many arguments for this mode. Some will be ignored.\n');end       case {'data', 'd'},       fprintf('Call in straight mode, with some data\n');       if(lp <5)         msg = 'Some essential data are forgotten for this mode';         return;       end       v = P(3); RI = cat(1,v{:});       if(isempty(RI)) msg ='RI input vector is empty!'; return; end       v = P(4); RItime = cat(1, v{:});       if(isempty(RItime)) msg ='RItime input vector is empty!'; return;end       v = P(5); sr = cat(1,v{:});        if(isempty(sr)) msg ='Sampling rate field is empty!'; return;end              if(lp >=6)         nameout = char(P(6));         if (isempty(nameout))          nameout = 'doutsig.aif';          fprintf('No output name provided. File will be saved as AIFF : %s\n', nameout);         end       else         nameout = 'doutsig.aif';         fprintf('No output name provided. File will be saved as AIFF : %s\n', nameout);       end       if(lp >=7) A_winname = char(P(7)); else A_winname = 'harris';end       if(isempty(A_winname)) A_winname = 'harris';end       if(lp >=8) v = P(8); A_nfft = cat(1, v{:}); else A_nfft = 512; end        if(isempty(A_nfft)) A_nfft = 512; end       if(lp >=9) v = P(9); A_overlap = cat(1, v{:}); else A_overlap = 0.75; end        if(isempty(A_overlap)) A_overlap = 0.75; end       if(lp >=10) v = P(10); A_Trev = cat(1, v{:}); else A_Trev = 100; end       if(isempty(A_Trev)) A_Trev = 100; end       if(lp >=11) v = P(11); Nrepeat = cat(1, v{:}); else Nrepeat = 12; end       if(isempty(Nrepeat)) Nrepeat = 12; end       if(lp >=12) fprintf('Too many arguments for this mode. Some will be ignored.\n');end    otherwise,      msg = 'Unknown submod';    end   case {'file','f'}     fprintf('Call in file mode\n');     return; %due to a strange feature about reading file in subfunctions   case {'dir','d'}   msg ='Feature not yet implemented'; otherwise,   msg = 'Unknown mode';endfunction [finalfilter] = testfilter(thekeepfilter, inputsigName)finalfilter = []; %[Tr,P0,TLim,PNoise, Tbegin,RI,RItime,RIsynt, STFT, STFTfreq, STFTtime,EDR]path = '';r = inputsigName;idx = 0;bsflag = 0;    if(strcmp(inputsigName(1), '/'))     bsflag = 1;endwhile(~isempty(r))  idx = idx+1;  [t r] = strtok(r,'/');end    r = inputsigName;for i=1:idx-1  [t r] = strtok(r,'/');  if(~isempty(path))     path = [path '/' t];  else     path = t;  endendif(~isempty(path))   path = [path '/'];   ln = length(r);   kName = r(2:ln);   if(bsflag == 1)     path = ['/' path];   endelse       kName = r;end [begstr endstr ] = strtok(kName, '.');matname = [path begstr '.mat'];r = thekeepfilter;finalfilter = ['save ' matname ];tempffilter = finalfilter; allflag = 0;while(~isempty(r)) [t r] = strtok(r,' ,;'); f = deblank(t); switch(f)  case 'Tr', finalfilter = [finalfilter ' Tr'];  case 'P0', finalfilter = [finalfilter ' P0'];  case 'TLim', finalfilter = [finalfilter ' TLim'];  case 'PNoise', finalfilter = [finalfilter ' PNoise'];  case 'Tbegin', finalfilter = [finalfilter ' Tbegin'];  case 'RI', finalfilter = [finalfilter ' RI'];  case 'RItime', finalfilter = [finalfilter ' RItime'];  case 'RIsynt', finalfilter = [finalfilter ' RIsynt'];  case 'STFT', finalfilter = [finalfilter ' STFT'];  case 'STFTfreq', finalfilter = [finalfilter ' STFTfreq'];  case 'STFTtime', finalfilter = [finalfilter ' STFTtime'];  case 'EDR', finalfilter = [finalfilter ' EDR'];  case 'all', allflag = 1;break; endendif(strcmp(finalfilter, tempffilter)) if(allflag == 1)    else   finalfilter = []; endend