function [EDR] = edr(Nfft, R_overlap,SFCT, SFCTtime,PNoise,P0, Tr, TLim)% EDR %%	[EDR] = edr(nfft,roverlap,STFT,STFTtime); %       [EDR] = edr(nfft,roverlap,STFT,STFTtime,PNoise);%       [EDR] = edr(nfft,roverlap,STFT,STFTtime,PNoise,P0,Tr,TLim);%% Compute the energy decay relief (EDR) for a given short time Fourier% transform. It can be used for only one channel of STFT too. The number% of input arguments can vary, allowing different uses.% %     - 4 arguments : computation of the EDR%     - 5 arguments : before computation, a constant value (cooruption noise%                     PNoise) is substracted to each channel of the STFT%     - 8 arguments : same as above, but a theoretical value correponding to %                     an exponential decay is output when the result would have%                     been corrupted by noise%% nfft     : Number of points in FFT computing for the short-time Fourier transform% roverlap : Overlap rate of the windows% STFT     : short-time Fourier transform to be integrated% STFTtime : time scale corresponding to the STFT time dimension% PNoise   : Corrupting noise, (Computed after a call to EDRanalysis). Its lengths%            must be the same as the frequency dimension of STFT% P0       : Initial Power Spectrum(computed after a call to EDRanalysis)% Tr       : Reverberation time (computed after a call to EDRanalysis)% TLim     : Noise Limit Time (computer after a call to EDRanalysis)% % See also : STFT, STFS, EDRanalysisNChanTime = length(SFCTtime);Thesize = size(SFCT);                      % Faire en sorte que lesif (Thesize(1) == NChanTime)               % isofrequences soient en ligne	SFCTsig = SFCTsig';endNChanfreq = Thesize(1);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% OW 28 mai DeltaTime = 1 %%%%%%%%%%%%%%%%%%%%%%%%%%%%DeltaTime = 1;%%%%%%%%%%%%%%%%%%%%%%% OW 30 mai DeltaTime = 1 %%%%%%%%%%%%%DeltaTime = (1-Roverlap)*Nfft;%%%%%% REMPLACE UNIQUEMENT DANS LE GOOD CAS %%%%Delta = (1-R_overlap)*Nfft;DeltaTime = SFCTtime(2)-SFCTtime(1);if( nargin == 4)    PNoise = zeros(1,NChanfreq);  EDR = SFCT-(PNoise'*ones(1,NChanTime));  EDR = Delta.* flipud(cumsum(flipud(EDR')))';   EDR = max(EDR, zeros(size(EDR)));elseif(nargin == 5)    EDR = SFCT-(PNoise'*ones(1,NChanTime));  EDR = Delta.* flipud(cumsum(flipud(EDR')))';   EDR = max(EDR, zeros(size(EDR)));elseif(nargin == 8)  %%LE GOOD CAS  EDR = SFCT-(PNoise'*ones(1,NChanTime));  EDR = max(EDR, zeros(size(EDR)));   for(i = 1:NChanfreq)    tl = TLim(i);        if(tl < SFCTtime(1))            NoiseIndex = [1:length(SFCTtime)];      SigIndex = [];    else      SigIndex = find(tl > SFCTtime);     if( ~isempty(SigIndex))       NoiseIndex = [SigIndex(length(SigIndex))+1: length(SFCTtime)];      else       NoiseIndex = [1:length(SFCTtime)];     end        end	   %fprintf('index %d, temps %f ,taille %d\n',i, tl,length(SigIndex));   SigTime = SFCTtime(SigIndex);      NoiseTime = SFCTtime(NoiseIndex);   EDR(i,NoiseIndex) = (P0(i)*exp(-6*log(10)*(NoiseTime/Tr(i))));       residu(i) =  P0(i)*Tr(i)*exp(-6*log(10)*(SFCTtime(length(SFCTtime))+DeltaTime)/Tr(i))/(6*log(10))/DeltaTime;      end        %Cumul retrograde temporelle   %en verite il s'agit d'un temps de 1   EDR = Delta*flipud(cumsum(flipud(EDR')))';      for(i = 1:NChanfreq)     EDR(i,:) = EDR(i,:)+Delta*residu(i);   end    %EDR = max(EDR, zeros(size(EDR)));   Delta;else fprintf('Bad Argument number\n');end