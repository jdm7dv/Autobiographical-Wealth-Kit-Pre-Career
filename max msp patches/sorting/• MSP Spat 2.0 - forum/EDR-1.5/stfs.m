function [SFCTsig, SFCTtime, SFCTfreq] = stfs(sig, fe,Win, Nfft, Roverlap)% STFS%%     [STFS, STFStime, STFSfreq] = stfs(sig, fe, win, nfft, roverlap)% % Compute the short time Fourier spectrum of a signal 'sig'. % The beginning of the signal is zero-padded with Nfft/2 zeros% so that the beginning of the signal is not ignored. The result% represents an energy. It is stored in a matrix, whose lines % represents one FFT channel (isofrequency) and raws one FFT.% Two additionnals vectors 'time' and 'freq' represent the scales% associated with STFS. It uses the 'STFT' function%	% sig      : input signal% fe       : Sampling rate of the signal 'sig'% win      : Vector of the analysis window% nfft     : Number of points in FFT computing;%            must be equal to the length of win% roverlap : Overlap rate of the windows%% STFS     : Matrix of the Short time fourier spectrum.% time     : Temporal scale associated with the STFS (in s)% freq     : Frequency scale associated with the STFS (in Hz)%% Default  : fe = 1, win : Blackmann-Harris window (order 4), nfft = 1024,%            roverlap = 0.75;%% See also : STFT, SPECGRAM%%%%% OW 28 Mai Norme = sum(win.*win)/(0.25*Nfft);%%%%% OW 30 Mai Norme = sum(win.*win);sig = sig(:); fprintf('Computing short-time Fourier spectrum\n')Win = Win(:);if (nargin == 5)  fprintf('Window size : %d, ', Nfft);  fprintf('overlap %s\n',Roverlap);  sig = [zeros(1, Nfft/2) sig'];    NsampleOverlap = Roverlap*Nfft;    TFCTsig = specgram(sig, Nfft,[], Win, NsampleOverlap);%%%%% OW 28 Mai Norme = sum(win.*win)/(0.25*Nfft);%%Norme = sum(Win.*Win)/((1-Roverlap)*Nfft);%%%%% OW 30 Mai Norme = sum(win.*win);Norme = sum(Win.*Win);  SFCTsig = (abs(TFCTsig).^2)/(Norme);    Ssize = size(SFCTsig);  SFCTtime = ([1:Ssize(2)]-1)*(Nfft-NsampleOverlap)/fe;  SFCTfreq = ([1: Ssize(1)]-1)*fe/Nfft;  elseif (nargin == 1)    fprintf('Default Values : \n');  fprintf('Window size : %d, ', Nfft);  fprintf('Overlap %s\n',Roverlap);  fprintf('Temporal and frequential scales in samples \n');  Nfft = 1024;  fe = 1;  Roverlap = 3/4;  NsampleOverlap = Nfft*3/4;  Win = harris(1024);  sig = [zeros(1, Nfft/2) sig']  %%sig = [zeros(Nfft/2, 1); sig];    fprintf('fenetre de Harris, %d points \n', Nfft);  fprintf('Recouvrement 3/4 taille de fft (%d points)\n\n',0.75*Nfft);    TFCTsig = specgram(sig, Nfft,[], Win, NsampleOverlap);  Norme = sum(Win.*Win)/((1-Roverlap)*Nfft);  SFCTsig = (abs(TFCTsig).^2)/(Norme);    Ssize = size(SFCTsig);  SFCTtime = [1:Ssize(2)];  SFCTfreq = [1:Ssize(1)];;  else  Nfft = 1024;  NsampleOverlap = Nfft*3/4;  Roverlap = 3/4;  fprintf('Taille de FFT : %d \n', Nfft);  fprintf('Valeurs par defaut\n');    sig = [zeros(1, Nfft/2) sig'];  %%sig = [zeros(Nfft/2, 1); sig];  Win = harris(Nfft);    TFCTsig = specgram(sig, Nfft,[], Win, NsampleOverlap);  Norme = sum(Win.*Win)/((1-Roverlap)*Nfft);  SFCTsig = (abs(TFCTsig).^2)/(Norme);    Ssize = size(SFCTsig);  SFCTtime = ([1:Ssize(2)]-1)*(Nfft-NsampleOverlap)/fe;  SFCTfreq = ([1: Ssize(1)]-1)*fe/Nfft;end