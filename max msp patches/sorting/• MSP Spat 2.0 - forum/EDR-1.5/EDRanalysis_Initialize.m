function [Tr, P0, PNoise,InitError] = EDRanalysis_Iteration(ETC,ETCtime,N,Nfft, R_overlap)% EDRanalysis_Initialize%% [Tr, P0, PNoise, InitError] = EDRanalysis_Initialize(ETC,ETCtime,N,nfft, roverlap)%% Having a single short-time Fourier transform channel(ETC) of an room ipulse response, % this function computes values of reverberation time (Tr),Initial Power Spectrum (P0), % and corrupting noise (PNoise) for that channel. This is made by comparing energu levels% in different sections of the channel (segmentation in N sections), and then using% the Energy Decay Curve properties. An error is computed, as the quadratic difference % between the STFT Channel (ETC) and the theoretical curve obtained using the estimated % parameters (exponential decreasing curve ETC=P0*exp(-60/Tr)).%% In order to have better estimation, only the diffuse part of the ETC should be% passed to this routine (pre-elimination of the first reflections, ETC is truncated).%% ETC     : channel of the short-time Fourier transform of the signal, with first%           reflections eliminated% ETCtime : corresponding time scale% N       : number of division made in ETC for the initialization (segmentation) % nfft    : number of points used in the FFT for the short-time Fourier transform% roverlap: overlap rate of the windows during STFT%% Tr      : Value of Tr after the iniialization% P0      : Value of P0 (Initial Power Spectrum) after the initialization% PNoise  : Value of the energy of the corrupting noise after the initialization%% See also : EDRanalysis_Iteration, EDRanalysis, edr, stft.ETC = ETC(:);ETC = ETC';ETCtime = ETCtime(:);ETCtime = ETCtime';% Computation of useful valuesEndTime = length(ETCtime);DeltaTime = ETCtime(2)-ETCtime(1);Delta = Nfft*(1- R_overlap);pas = fix(length(ETC)/N);% Preparation : segmentation matrix, segmentation indices vector, criterium vector%plot(ETCtime, PowerLog(ETC))index = (pas:pas:(N-1)*pas);Matsig = zeros(pas,N);Mattime = zeros(pas,N);for i=1:N Matsig(:,i) = ETC(1+(i-1)*pas :i*pas)'; mattime(:,i)  = ETCtime(1+(i-1)*pas:i*pas)';end	% Estimating the parametersPNoise = mean(Matsig);u = [1:length(PNoise)];u = fliplr(u);vec = fliplr(cumsum(fliplr(PNoise)));PNoise2 = vec./u;Comp = PNoise - PNoise2;LimitZone = find((PNoise-PNoise2) <= 0);IndexZone = max(LimitZone(1),1); if (IndexZone == N)   vectime = mattime(:,N)';   vecsig = PowerLog(Matsig(:,N)');      Pol0 = polyfit(vectime, vecsig,0);   Pol1 = polyfit(vectime, vecsig,1);       PNoise =mean(Matsig(:,N)');   SigZone = (1:N*pas-1);   else   NoiseZone = (fix((1+(IndexZone-1)*pas+IndexZone*pas)/2) :  length(ETCtime));   NoiseTime = ETCtime(NoiseZone);   NoiseVec = ETC(NoiseZone);       PNoise = mean(NoiseVec);   SigZone = (1: max(fix(pas/2), (1+(IndexZone-2)*pas+(IndexZone-1)*pas)/2));endEDR = edr(Nfft, R_overlap, ETC,ETCtime,PNoise);NonValid = find(EDR == 0);% Estimating Tr and P0% Using Eergy decay relief properties, and linear regressionif(~isempty(NonValid))   SigZone = [SigZone(1): min(NonValid(1), SigZone(length(SigZone)))];endSigTime = ETCtime(SigZone);SigVec = PowerLog(EDR(SigZone));if length(SigTime) > 3   Pol=polyfit(SigTime, SigVec,1);   Tr = -60/Pol(1);   Tr = min(Tr,20);   a = -60/Tr;   P0 = DeltaTime/Delta*6*log(10)*min(PowerExp(Pol(2)), EDR(1))/Tr;   z0 = PowerLog(P0);   cz0 = z0-a*ETCtime(1);   P0 = PowerExp(cz0);else  Tr = -1;endif (Tr < 0)  mid = floor(length(ETCtime)/2);  Pol=polyfit(ETCtime(1:mid), PowerLog(ETC(1:mid)),1);  Tr = -60/Pol(1);  Tr = min(Tr, 20);  Tr = max(Tr, 0.001);  a = -60/Tr;  P0 = DeltaTime/Delta*6*log(10)*min(PowerExp(Pol(2)), EDR(1))/Tr;  P0 = max(P0,eps);  z0 = PowerLog(P0);  cz0 = z0-a*ETCtime(1);end% Iniial error computationif(PNoise ~= 0) Tlim = -Tr*log10(PNoise/P0)/6;else Tlim = ETCtime(length(ETCtime));endTlim = max(Tlim, ETCtime(2));Tlim = min(Tlim, ETCtime(length(ETCtime)));SigIndex= find(ETCtime<=Tlim);SigTime = ETCtime(SigIndex);Pol = [-60/Tr PowerLog(P0)];VecError = ETC(SigIndex) - PowerExp(polyval(Pol, SigTime));InitError = (norm(VecError)^2)/length(VecError);%figure%plot(ETCtime, PowerLog(ETC))%hold on%grid%plot(0, PowerLog(P0), 'or');