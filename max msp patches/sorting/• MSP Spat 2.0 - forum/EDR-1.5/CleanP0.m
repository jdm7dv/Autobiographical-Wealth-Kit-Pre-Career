function [P0_sm, index] = CleanP0(Freq,P0, Tr_sm,Index, EDR, Res)% CleanP0% %   [P0_New, index] = CleanP0(Freq,P0, Tr_New,IndexTr, EDR, Res)%% This function smooths the initial power spectrum  made after % raw time-frequency analysis, thus eliminating non-coherent values% It is used inside the RIanalyse function, and follow a call to CleanTr.% % % Freq    : Frequency scale issued after a short-time Fourier transform% P0      : Initial Power Spectrum before smoothing.% Tr_New  : reverberation time calculated by CleanTr% IndexTr : vector of indexes where the Tr was corrected (output%           of CleanTr)% EDR     : value of the origin of the energy decay relief of %           the initial impulse response (call of EDRanalysis_Iteration)% Res     : residual values computed  by EDRanalysis_Iteration%% P0_New  : Initial Power Spectrum after smoothing% index   : vector of indexes where the P0 has been corrected%% See Also : CleanP0, RIanalyse, EDRanalysis_Iterationindex = [];P0_sm = [];DeltaTime = Freq(2)-Freq(1);%%enleve les valeurs isnany = P0; y = real(y);y = max(y, zeros(size(y)));y = CorrectNaN(y);P0_sm = y;%%Correction due au Trfor i=1:length(Index)  place = Index(i);  coeff = 1-exp(-6*log(10)*DeltaTime/Tr_sm(place));  P0_sm(place) = EDR(place)*coeff/DeltaTime - Res(place);endP0_sm = max(P0_sm, zeros(size(P0_sm)));%keyboardIndinf = find(Freq < 12000);Indsup = find(Freq >=12000);if(isempty(Indsup))else	medinf = median(PowerLog(P0_sm(Indinf)));	medsup = median(PowerLog(P0_sm(Indsup)));	mininf = min(PowerLog(P0_sm(Indinf)));	maxinf = max(PowerLog(P0_sm(Indinf)));	minsup = min(PowerLog(P0_sm(Indsup)));	maxsup = max(PowerLog(P0_sm(Indsup)));             	[h val]= hist(PowerLog(P0_sm(Indinf)));	vrac = [];	x = find(h ~= 0); %endroit ou l' histogramme est non nul            for i=1: length(x)-1         if(x(i+1)-x(i) > 2)           vrac = [vrac x(i+1)];         end       end       value = min(val(vrac));       if(~isempty(value))          x = find( PowerLog(P0_sm(Indinf)) >=  value);          for i=1:length(x)           if x(i) == 1             P0_sm(1) = 0.5*(P0_sm(2)+P0_sm(3));           else             P0_sm(x(i)) = 0.5*(P0_sm(x(i)-1)+P0_sm(x(i)+1));           end        end      end           medinf = median(PowerLog(P0_sm(Indinf)));      stdinf = std(PowerLog(P0_sm(Indinf)));      Infvec = PowerLog(P0_sm(Indinf));      supvec = PowerLog(P0_sm(Indsup));      x = find(supvec > medinf+2*stdinf);      if (isempty(x))      else        Prun = 1;        while(Prun <= length(x))      	 Pbegin = x(Prun);     	 Pend = x(Prun);            	 if (Prun < length(x))       	 	while((x(Prun+1) == x(Prun)+1))                     if(Prun < length(x))         		Pend = x(Prun+1);         		Prun = Prun+1;                        if(Prun == length(x))                             break                        end                     else                        Pend = x(length(x));                        break;                     end       		end     	else        	Pend = x(length(x));     	end          %fprintf('%d\t %d\n', Pbegin,Pend)     	if(Pbegin == 1)      		if (Pend == length(Indsup))        		slope = (supvec(Pend+1)- Infvec(length(Infvec)))/(Pend+2);        		yor = supvec(Pend+1) - slope*(Pend+1);        		for j = Pbegin:Pend          			supvec(j) = slope*j+yor;        		end      		else        		for j = Pbegin:Pend          			supvec(j) = PowerLog(eps);        		end      		end    	else      		if (Pend == length(Indsup))        		for j = Pbegin:Pend         			supvec(j) = supvec(Pbegin-1);        		end      		else       			slope =  (supvec(Pend+1)-supvec(Pbegin -1))/(Pend-Pbegin+2);       			yor = supvec(Pend+1) - slope*(Pend+1);       			for j = Pbegin:Pend         			supvec(j) = slope*j+yor;       			end    		end   	end 		Prun = Prun+1;    endend  P0_sm(Indsup) = PowerExp(supvec);end